[
  {
    "name": "src",
    "type": "directory",
    "path": "src",
    "children": [
      {
        "name": "1.数组",
        "type": "directory",
        "path": "src/1.数组",
        "children": [
          {
            "name": "1.二分查找.ts",
            "type": "file",
            "path": "src/1.数组/1.二分查找.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/binary-search/description/\n */\nfunction search(nums: number[], target: number): number {\n    let left = 0,\n        right = nums.length - 1\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2)\n        if (nums[mid] === target) return mid\n        if (nums[mid] < target) {\n            left = mid + 1\n        }\n        if (nums[mid] > target) {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\nconsole.log(search([1, 2, 3, 4, 5], 2))\n",
            "url": "https://leetcode.cn/problems/binary-search/description/",
            "sortKey": 1
          },
          {
            "name": "2.移除元素.ts",
            "type": "file",
            "path": "src/1.数组/2.移除元素.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/remove-element/description/\n */\nfunction removeElement(nums: number[], val: number): number {\n  let slow = 0,\n    fast = 0;\n  while (fast < nums.length) {\n    nums[slow] = nums[fast]; // PS: 这里可以优化，不需要交换，直接覆盖即可。\n    if (nums[fast] === val) {\n      fast++;\n    } else {\n      slow++;\n      fast++;\n    }\n  }\n  return slow;\n}\nconsole.log(removeElement([3, 2, 2, 3], 3));\n",
            "url": "https://leetcode.cn/problems/remove-element/description/",
            "sortKey": 2
          },
          {
            "name": "3.有序数组的平方.ts",
            "type": "file",
            "path": "src/1.数组/3.有序数组的平方.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/squares-of-a-sorted-array/description/\n */\nfunction sortedSquares(nums: number[]): number[] {\n  const result: number[] = [];\n  let left = 0,\n    right = nums.length - 1;\n  while (left <= right) {\n    let leftRow = Math.pow(nums[left], 2),\n      rightRow = Math.pow(nums[right], 2);\n    if (leftRow <= rightRow) {\n      result.unshift(rightRow);\n      right--;\n    } else {\n      result.unshift(leftRow);\n      left++;\n    }\n  }\n  return result;\n}\nconsole.log(sortedSquares([-4, -1, 0, 3, 10]));\n",
            "url": "https://leetcode.cn/problems/squares-of-a-sorted-array/description/",
            "sortKey": 3
          },
          {
            "name": "4.长度最小的子数组.ts",
            "type": "file",
            "path": "src/1.数组/4.长度最小的子数组.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/minimum-size-subarray-sum/\n */\nfunction minSubArrayLen(target: number, nums: number[]): number {\n    let left = 0,\n        res = Number.MAX_SAFE_INTEGER,\n        sum = 0\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i]\n        while (sum >= target) {\n            res = Math.min(i - left + 1, res)\n            sum -= nums[left++]\n        }\n    }\n    return res === Number.MAX_SAFE_INTEGER ? 0 : res\n}\n\n",
            "url": "https://leetcode.cn/problems/minimum-size-subarray-sum/",
            "sortKey": 4
          },
          {
            "name": "5.螺旋矩阵2.ts",
            "type": "file",
            "path": "src/1.数组/5.螺旋矩阵2.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/spiral-matrix-ii/description/\n */\nfunction generateMatrix(n: number): number[][] {\n    let top = 0,\n        bottom = n - 1,\n        left = 0,\n        right = n - 1,\n        count = 0, // 转几圈\n        result = new Array(n).fill(0).map((_item) => new Array(n).fill(0)),\n        num = 1\n    while (count <= Math.floor(n / 2)) {\n        // notice:执行一个循环需要做的事情\n        for (let i = left; i <= right; i++) {\n            result[top][i] = num++\n        }\n        top += 1\n        for (let i = top; i <= bottom; i++) {\n            result[i][right] = num++\n        }\n        right -= 1\n        for (let i = right; i >= left; i--) {\n            result[bottom][i] = num++\n        }\n        bottom -= 1\n        for (let i = bottom; i >= top; i--) {\n            result[i][left] = num++\n        }\n        left += 1\n        count += 1\n    }\n    return result\n}\nconsole.table(generateMatrix(100))\n",
            "url": "https://leetcode.cn/problems/spiral-matrix-ii/description/",
            "sortKey": 5
          }
        ],
        "sortKey": 1
      },
      {
        "name": "2.链表",
        "type": "directory",
        "path": "src/2.链表",
        "children": [
          {
            "name": "1.移除链表元素.ts",
            "type": "file",
            "path": "src/2.链表/1.移除链表元素.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/remove-linked-list-elements/description/\n */\n\nclass ListNode {\n    val: number\n    next: ListNode | null\n    constructor(val?: number, next?: null) {\n        this.val = val === undefined ? 0 : val\n        this.next = next === undefined ? null : next\n    }\n}\n\nfunction removeElements(head: ListNode | null, val: number): ListNode | null {\n    if (!head) return null\n    let vitrualHead = new ListNode(0)\n    vitrualHead.next = head\n    let fast: ListNode | null = head,\n        slow = vitrualHead\n    while (fast) {\n        if (fast.val === val) {\n            slow.next = fast.next\n            fast = fast.next\n        } else {\n            slow = fast\n            fast = fast.next\n        }\n    }\n    return vitrualHead.next\n}\n",
            "url": "https://leetcode.cn/problems/remove-linked-list-elements/description/",
            "sortKey": 1
          },
          {
            "name": "2.设计链表.ts",
            "type": "file",
            "path": "src/2.链表/2.设计链表.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/design-linked-list/\n * @description 实现 MyLinkedList 类：\n  MyLinkedList() 初始化 MyLinkedList 对象。\n   int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\n   void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\n   void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\n   void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\n   void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\n */\n\nclass MyLinkedList {\n    val: number\n    next: null | MyLinkedList\n    constructor(val: number, next: null | MyLinkedList) {\n        this.val = val\n        this.next = next\n    }\n\n    get(index: number): number {\n        let count = 0,\n            prev: MyLinkedList | null = this\n        while (count <= index) {\n            if (prev) {\n                prev = prev.next\n            }\n            count++\n        }\n        if (prev) return prev.val\n        return -1\n    }\n\n    addAtHead(val: number): void {\n        let newHead = new MyLinkedList(val, this)\n        this.next = newHead\n    }\n\n    addAtTail(val: number): void {\n        let prev: MyLinkedList | null = this\n        while (prev?.next) {\n            prev = prev.next\n        }\n        let newHead = new MyLinkedList(val, null)\n        prev.next = newHead\n    }\n\n    addAtIndex(index: number, val: number): void {\n        let count = 0,\n            prev: MyLinkedList | null = this,\n            newHead = new MyLinkedList(val, null)\n        while (count <= index) {\n            if (prev) {\n                prev = prev.next\n            }\n            count++\n        }\n        if (prev) {\n            prev.next = newHead\n        }\n    }\n\n    deleteAtIndex(index: number): void {\n        let count = 0,\n            prev: MyLinkedList | null = this\n        while (count <= index - 1 && prev) {\n            prev = prev.next\n            count++\n        }\n        if (prev) {\n            prev.next = !prev.next ? null : prev.next.next\n        }\n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = new MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(val)\n * obj.addAtTail(val)\n * obj.addAtIndex(index,val)\n * obj.deleteAtIndex(index)\n */\n",
            "url": "https://leetcode.cn/problems/design-linked-list/",
            "sortKey": 2
          },
          {
            "name": "3.反转链表.ts",
            "type": "file",
            "path": "src/2.链表/3.反转链表.ts",
            "content": "/**\n * @url https://leetcode.cn/problesms/reverse-linked-list/description/\n */\n\nclass ListNode {\n    val: number\n    next: ListNode | null\n    constructor(val?: number, next?: null) {\n        this.val = val === undefined ? 0 : val\n        this.next = next === undefined ? null : next\n    }\n}\nfunction reverseList(head: ListNode | null): ListNode | null {\n    if (!head) return null\n    let pre = head,\n        qo = head,\n        fast = head.next\n    while (fast && fast.next) {\n        qo = fast\n        fast = fast.next\n        qo.next = pre\n        pre = qo\n    }\n    return fast\n}\n\n// 1 2 3 4 5\n",
            "url": "https://leetcode.cn/problesms/reverse-linked-list/description/",
            "sortKey": 3
          },
          {
            "name": "4.两两交换链表中的节点.ts",
            "type": "file",
            "path": "src/2.链表/4.两两交换链表中的节点.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/swap-nodes-in-pairs/description/\n */\n\nclass ListNode {\n    val: number\n    next: ListNode | null\n    constructor(val?: number, next?: null) {\n        this.val = val === undefined ? 0 : val\n        this.next = next === undefined ? null : next\n    }\n}\nexport {}\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if (!head) return null\n    if (!head.next) return head\n    let vitrualNode: ListNode | null = new ListNode(0)\n    vitrualNode.next = head\n    let cur: ListNode | null = vitrualNode\n    while (cur && cur.next && cur.next.next) {\n        let p = cur.next,\n            q = cur.next.next\n        p.next = q.next\n        q.next = p\n        cur.next = q\n        cur = cur.next!.next\n    }\n    return vitrualNode.next\n}\n\n// notice 要思考一个节点换位后前后关联的关系\n",
            "url": "https://leetcode.cn/problems/swap-nodes-in-pairs/description/",
            "sortKey": 4
          },
          {
            "name": "5.删除链表的倒数第n个节点.ts",
            "type": "file",
            "path": "src/2.链表/5.删除链表的倒数第n个节点.ts",
            "content": "// @ts-nocheck\n/**\n * @url https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/\n */\nclass ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\nexport {};\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\n//  v 1 1\nvar removeNthFromEnd = function (head, n) {\n  const Vnode = new ListNode(0, head);\n  let fast = Vnode;\n  let count = 0;\n  while (count < n) {\n    fast = fast.next;\n    count++;\n  }\n  let slow = Vnode;\n  while (fast.next) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n  slow.next = slow.next.next;\n  return Vnode.next;\n};\n",
            "url": "https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/",
            "sortKey": 5
          },
          {
            "name": "6.链表相交.js",
            "type": "file",
            "path": "src/2.链表/6.链表相交.js",
            "content": "/**\n * @url https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/\n */\nfunction ListNode(val) {\n    this.val = val\n    this.next = null\n}\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\n\nconst getLens = (head) => {\n    let count = 0,\n        curNode = head\n    while (curNode) {\n        count++\n        curNode = curNode.next\n    }\n    return count\n}\n\nvar getIntersectionNode = function (headA, headB) {\n    let len1 = getLens(headA),\n        len2 = getLens(headB),\n        curNodeA = headA,\n        curNodeB = headB,\n        chazhi = Math.abs(len1 - len2),\n        count = 0\n    if (len1 > len2) {\n        while (count < chazhi) {\n            curNodeA = curNodeA.next\n            count++\n        }\n    } else {\n        while (count < chazhi) {\n            curNodeB = curNodeB.next\n            count++\n        }\n    }\n\n    while (curNodeA) {\n        if (curNodeA === curNodeB) return curNodeA\n        curNodeA = curNodeA.next\n        curNodeB = curNodeB.next\n    }\n    return null\n}\n",
            "url": "https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/",
            "sortKey": 6
          },
          {
            "name": "7.环形链表.ts",
            "type": "file",
            "path": "src/2.链表/7.环形链表.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/linked-list-cycle-ii/\n */\n\nclass ListNode {\n    val: number\n    next: ListNode | null\n    constructor(val?: number, next?: null) {\n        this.val = val === undefined ? 0 : val\n        this.next = next === undefined ? null : next\n    }\n}\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    let slow: ListNode | null = head,\n        fast: ListNode | null = head\n    while (slow && fast && fast.next) {\n        slow = slow.next\n        fast = fast.next.next\n        if (slow === fast) {\n            // 这个时候是相遇点\n            slow = head\n            while (slow !== fast) {\n                slow = slow!.next\n                fast = fast!.next\n            }\n            return slow\n        }\n    }\n    return null\n}\n",
            "url": "https://leetcode.cn/problems/linked-list-cycle-ii/",
            "sortKey": 7
          },
          {
            "name": "8.判断链表是否有环.ts",
            "type": "file",
            "path": "src/2.链表/8.判断链表是否有环.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/linked-list-cycle/description/\n */\nexport {}\nclass ListNode {\n    val: number\n    next: ListNode | null\n    constructor(val?: number, next?: null) {\n        this.val = val === undefined ? 0 : val\n        this.next = next === undefined ? null : next\n    }\n}\nfunction hasCycle(head: ListNode | null): boolean {\n    if (!head) return false\n    if (!head.next) return false\n    let slow: ListNode | null = head,\n        fast: ListNode | null = head\n    while (slow && fast) {\n        slow = slow.next\n        fast = fast.next?.next || null\n        if (slow === fast) {\n            return true\n        }\n    }\n    return false\n}\n",
            "url": "https://leetcode.cn/problems/linked-list-cycle/description/",
            "sortKey": 8
          },
          {
            "name": "9.合并两个有序链表.ts",
            "type": "file",
            "path": "src/2.链表/9.合并两个有序链表.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/merge-two-sorted-lists/description/\n */\nclass ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\n// !分而治之中的治\nfunction mergeTwoLists(\n  list1: ListNode | null,\n  list2: ListNode | null\n): ListNode | null {\n  let _vitrual = new ListNode(0); // 虚拟头结点\n  let cur1 = list1,\n    cur2 = list2,\n    _head = _vitrual;\n\n  while (cur1 && cur2) {\n    if (cur1.val < cur2.val) {\n      _head.next = cur1;\n      cur1 = cur1.next;\n      _head = _head.next;\n    } else {\n      _head.next = cur2;\n      cur2 = cur2.next;\n      _head = _head.next;\n    }\n  }\n  if (cur1) {\n    _head.next = cur1;\n    cur1 = cur1.next;\n  }\n  if (cur2) {\n    _head.next = cur2;\n    cur2 = cur2.next;\n  }\n  return _vitrual.next;\n}\n",
            "url": "https://leetcode.cn/problems/merge-two-sorted-lists/description/",
            "sortKey": 9
          },
          {
            "name": "10.合并k个有序链表.ts",
            "type": "file",
            "path": "src/2.链表/10.合并k个有序链表.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/merge-k-sorted-lists/description/\n */\n\nclass ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nfunction mergeTwoLists(\n  list1: ListNode | null,\n  list2: ListNode | null\n): ListNode | null {\n  let _vitrual = new ListNode(0); // 虚拟头结点\n  let cur1 = list1,\n    cur2 = list2,\n    _head = _vitrual;\n\n  while (cur1 && cur2) {\n    if (cur1.val < cur2.val) {\n      _head.next = cur1;\n      cur1 = cur1.next;\n      _head = _head.next;\n    } else {\n      _head.next = cur2;\n      cur2 = cur2.next;\n      _head = _head.next;\n    }\n  }\n  if (cur1) {\n    _head.next = cur1;\n    cur1 = cur1.next;\n  }\n  if (cur2) {\n    _head.next = cur2;\n    cur2 = cur2.next;\n  }\n  return _vitrual.next;\n}\n\n// function mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n//     if (lists.length === 0) return null\n//     if (lists.length === 1) return lists[0]\n//     let res: ListNode | null = null\n//     for (let i = 0; i < lists.length; i++) {\n//         res = mergeTwoLists(res, lists[i])\n//     }\n//     return res\n// }\n\nfunction mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n  if (lists.length === 0) return null;\n  if (lists.length === 1) {\n    return lists[0]; // ps：返回头结点\n  }\n  const midIndex = Math.floor(lists.length / 2);\n  const left = lists.slice(0, midIndex + 1);\n  const right = lists.slice(midIndex);\n  return mergeTwoLists(mergeKLists(left), mergeKLists(right));\n}\n",
            "url": "https://leetcode.cn/problems/merge-k-sorted-lists/description/",
            "sortKey": 10
          },
          {
            "name": "11.反转k个一组链表.ts",
            "type": "file",
            "path": "src/2.链表/11.反转k个一组链表.ts",
            "content": "// @ts-nocheck\n/**\n * @url https://leetcode.cn/problems/reverse-nodes-in-k-group/\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\n\nfunction ReverseHeadAndTail(head, tail) {\n  let pre = null,\n    cur = null,\n    fast = head;\n  while (fast !== tail) {\n    cur = fast;\n    fast = fast.next;\n    cur.next = pre;\n    pre = cur;\n  }\n  if (fast) {\n    cur = fast;\n    cur.next = pre;\n  }\n  return [cur, head];\n}\n\nvar reverseKGroup = function (head, k) {\n  const _VNode = new ListNode(0);\n  _VNode.next = head;\n  let fast = _VNode;\n  while (fast) {\n    let p = fast; // 翻转前的一个节点\n    let count = 0;\n    let tail = fast; // 要翻转链表的最后一个节点\n    while (count < k && tail) {\n      tail = tail.next;\n      count++;\n    }\n    if (k === count && tail) {\n      const tailNext = tail.next;\n      tail.next = null;\n      const [reverseHead, reverseTail] = ReverseHeadAndTail(p.next, tail);\n      p.next = reverseHead;\n      reverseTail.next = tailNext;\n      fast = reverseTail;\n    } else {\n      break; // ps: 不足k个直接退出循环了。\n    }\n  }\n  return _VNode.next;\n};\n",
            "url": "https://leetcode.cn/problems/reverse-nodes-in-k-group/",
            "sortKey": 11
          }
        ],
        "sortKey": 2
      },
      {
        "name": "3.哈希表",
        "type": "directory",
        "path": "src/3.哈希表",
        "children": [
          {
            "name": "1.有效的字母异位词.ts",
            "type": "file",
            "path": "src/3.哈希表/1.有效的字母异位词.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/valid-anagram/description/\n */\n\nfunction isAnagram(s: string, t: string): boolean {\n    const mapS = new Map()\n    for (let i = 0; i < s.length; i++) {\n        if (mapS.has(s[i])) {\n            mapS.set(s[i], mapS.get(s[i]) + 1)\n        } else {\n            mapS.set(s[i], 1)\n        }\n    }\n    for (let i = 0; i < t.length; i++) {\n        if (mapS.has(t[i])) {\n            mapS.set(t[i], mapS.get(t[i]) - 1)\n        } else {\n            return false\n        }\n    }\n\n    for (let value of mapS.values()) {\n        if (value !== 0) return false\n    }\n    return true\n}\n// notice：使用Map能够覆盖所有情况的字母异味词\n",
            "url": "https://leetcode.cn/problems/valid-anagram/description/",
            "sortKey": 1
          },
          {
            "name": "2.两个数组的交集.ts",
            "type": "file",
            "path": "src/3.哈希表/2.两个数组的交集.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/intersection-of-two-arrays/description/\n */\nfunction intersection(nums1: number[], nums2: number[]): number[] {\n    const set = new Set()\n    const set1 = new Set()\n    nums1.forEach((_num) => set.add(_num))\n    nums2.forEach((_num) => {\n        if (set.has(_num)) {\n            set1.add(_num)\n        }\n    })\n    return Array.from(set1) as number[]\n}\n\n// notice：在add的时候就已经去重了\n",
            "url": "https://leetcode.cn/problems/intersection-of-two-arrays/description/",
            "sortKey": 2
          },
          {
            "name": "3.快乐数.ts",
            "type": "file",
            "path": "src/3.哈希表/3.快乐数.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/happy-number/description/\n */\n\n// notice:取模技巧  从个位开始取\nconst getNext = (n) => {\n  let sum = 0;\n  while (n > 0) {\n    const digit = n % 10;\n    sum += digit * digit;\n    n = Math.floor(n / 10);\n  }\n  return sum;\n};\n\nconst getSqrtNum = (num: string) => {\n  let sum = 0;\n  for (let i = 0; i < num.length; i++) {\n    sum += Math.pow(Number(num[i]), 2);\n  }\n  return sum;\n};\nfunction isHappy(n: number): boolean {\n  const set = new Set();\n  while (true) {\n    if (n === 1) {\n      return true;\n    }\n    if (set.has(n)) return false;\n    set.add(n);\n    n = getSqrtNum(n.toString());\n  }\n}\n",
            "url": "https://leetcode.cn/problems/happy-number/description/",
            "sortKey": 3
          },
          {
            "name": "4.两数之和.ts",
            "type": "file",
            "path": "src/3.哈希表/4.两数之和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/two-sum/description/\n */\nfunction twoSum(nums: number[], target: number): number[] {\n    const map = new Map()\n    for (let index = 0; index < nums.length; index++) {\n        if (map.has(target - nums[index])) {\n            return [index, map.get(target - nums[index])]\n        }\n        map.set(nums[index], index)\n    }\n    return [-1, -1]\n}\n",
            "url": "https://leetcode.cn/problems/two-sum/description/",
            "sortKey": 4
          },
          {
            "name": "5.四数之和.ts",
            "type": "file",
            "path": "src/3.哈希表/5.四数之和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/4sum-ii/description/\n */\n// function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {\n//     let res1: number[] = [],\n//         res2: number[] = [],\n//         count = 0\n//     for (let i = 0; i < nums1.length; i++) {\n//         for (let j = 0; j < nums2.length; j++) {\n//             res1.push(nums1[i] + nums2[j])\n//         }\n//     }\n//     for (let i = 0; i < nums3.length; i++) {\n//         for (let j = 0; j < nums4.length; j++) {\n//             res2.push(nums3[i] + nums4[j])\n//         }\n//     }\n\n//     for (let i = 0; i < res1.length; i++) {\n//         for (let j = 0; j < res2.length; j++) {\n//             if (res1[i] + res2[j] === 0) {\n//                 count++\n//             }\n//         }\n//     }\n//     return count\n// }\n\nfunction fourSumCount(\n  nums1: number[],\n  nums2: number[],\n  nums3: number[],\n  nums4: number[]\n): number {\n  let map1 = new Map(),\n    map2 = new Map(),\n    count = 0;\n\n  for (let i = 0; i < nums1.length; i++) {\n    for (let j = 0; j < nums2.length; j++) {\n      let sum = nums1[i] + nums2[j];\n      if (map1.has(sum)) {\n        map1.set(sum, map1.get(sum) + 1);\n      } else {\n        map1.set(sum, 1);\n      }\n    }\n  }\n\n  for (let i = 0; i < nums3.length; i++) {\n    for (let j = 0; j < nums4.length; j++) {\n      let sum = nums3[i] + nums4[j];\n      if (map2.has(sum)) {\n        map2.set(sum, map2.get(sum) + 1);\n      } else {\n        map2.set(sum, 1);\n      }\n    }\n  }\n\n  for (let [key1, value1] of map1.entries()) {\n    for (let [key2, value2] of map2.entries()) {\n      if (key1 + key2 === 0) {\n        count += value1 * value2;\n      }\n    }\n  }\n\n  return count;\n}\n// notice:用数组来比较，最后会展示超时，优化的点就是利用Map减少最后遍历的次数\n",
            "url": "https://leetcode.cn/problems/4sum-ii/description/",
            "sortKey": 5
          },
          {
            "name": "6.赎金信.ts",
            "type": "file",
            "path": "src/3.哈希表/6.赎金信.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/ransom-note/description/\n */\nfunction canConstruct(ransomNote: string, magazine: string): boolean {\n    let arr = new Array(26).fill(0)\n    for (let index = 0; index < magazine.length; index++) {\n        arr[magazine[index].charCodeAt(0) - \"a\".charCodeAt(0)]++\n    }\n    for (let index = 0; index < ransomNote.length; index++) {\n        arr[ransomNote[index].charCodeAt(0) - \"a\".charCodeAt(0)]--\n    }\n    for (let index = 0; index < arr.length; index++) {\n        if (arr[index] < 0) {\n            return false\n        }\n    }\n    return true\n}\n",
            "url": "https://leetcode.cn/problems/ransom-note/description/",
            "sortKey": 6
          },
          {
            "name": "7.三数之和.ts",
            "type": "file",
            "path": "src/3.哈希表/7.三数之和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/3sum/description/\n */\n\n// -1 -1 -1 0 1 2\nfunction threeSum(nums: number[]): number[][] {\n    nums.sort((a, b) => a - b)\n    const res: number[][] = []\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue\n        }\n        let left = i + 1,\n            right = nums.length - 1\n        while (left < right) {\n            let sum = nums[i] + nums[left] + nums[right]\n            if (sum === 0) {\n                while (nums[left] === nums[left + 1]) {\n                    left++\n                }\n                while (nums[right] === nums[right - 1]) {\n                    right--\n                }\n                res.push([nums[i], nums[left], nums[right]])\n                right--\n                left++\n            } else if (sum < 0) {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n\n    return res\n}\n\n// notice：固定两边移动之间是可以覆盖全的，排列组合计算方式\n// todo:难点，关于找到后去重\n",
            "url": "https://leetcode.cn/problems/3sum/description/",
            "sortKey": 7
          },
          {
            "name": "8.四数之和.ts",
            "type": "file",
            "path": "src/3.哈希表/8.四数之和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/4sum/\n */\n// 这里的不重复是指值不能重复\n// 2 2 2 1 1\nfunction fourSum(nums: number[], target: number): number[][] {\n    const res: number[][] = []\n    nums.sort((a, b) => a - b)\n    for (let i = 0; i < nums.length - 3; i++) {\n        if (i > 0 && nums[i - 1] === nums[i]) {\n            continue\n        }\n        for (let j = i + 1; j < nums.length - 2; j++) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue // 如果是初始给过滤，那么将不会获取到这个值\n            let left = j + 1,\n                right = nums.length - 1\n            while (left < right) {\n                let sum = nums[left] + nums[right] + nums[i] + nums[j]\n                if (sum === target) {\n                    res.push([nums[left], nums[right], nums[i], nums[j]])\n                    while (nums[left] === nums[left + 1]) {\n                        left++\n                    }\n                    while (nums[right] === nums[right - 1]) {\n                        right--\n                    }\n                    left++\n                    right--\n                } else if (sum > target) {\n                    right--\n                } else {\n                    left++\n                }\n            }\n        }\n    }\n    return res\n}\n\n// -2 -1 0 0 1 2\n",
            "url": "https://leetcode.cn/problems/4sum/",
            "sortKey": 8
          }
        ],
        "sortKey": 3
      },
      {
        "name": "4.字符串",
        "type": "directory",
        "path": "src/4.字符串",
        "children": [
          {
            "name": "1.反转字符串.ts",
            "type": "file",
            "path": "src/4.字符串/1.反转字符串.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/reverse-string/\n */\n\nfunction reverseString(s: string[]): void {\n    let left = 0,\n        right = s.length - 1\n    while (right > left) {\n        ;[s[right], s[left]] = [s[left], s[right]]\n        right--\n        left++\n    }\n}\n",
            "url": "https://leetcode.cn/problems/reverse-string/",
            "sortKey": 1
          },
          {
            "name": "2.反转字符串二.ts",
            "type": "file",
            "path": "src/4.字符串/2.反转字符串二.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/reverse-string-ii/\n */\n\n// 字符串的长度为j-i+1 i+k其实就是索引在原先的基础上去加一了。所以这里判断的时候也就是判断index+k>s.length了\nfunction reverseStr(s: string, k: number): string {\n    for (let index = 0; index < s.length; index += 2 * k) {\n        if (index + k > s.length) {\n            s =\n                s.slice(0, index) +\n                s\n                    .slice(index + k)\n                    .split(\"\")\n                    .reverse()\n                    .join(\"\")\n        } else {\n            s =\n                s.slice(0, index) +\n                s\n                    .slice(index, index + k)\n                    .split(\"\")\n                    .reverse()\n                    .join(\"\") +\n                s.slice(index + k)\n        }\n    }\n    return s\n}\n\n// notice:主要坑点注意下标位置  index 后面的 index + k\n// notice:index 后面的 index + k\n",
            "url": "https://leetcode.cn/problems/reverse-string-ii/",
            "sortKey": 2
          },
          {
            "name": "3.反转字符串中的单词.ts",
            "type": "file",
            "path": "src/4.字符串/3.反转字符串中的单词.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/reverse-words-in-a-string/description/\n */\n\n// todo：获取字符串的单词\n// todo：死循环？不太可能，因为每一次循环都会走一次判空和非判空的处理。\nconst getTokens = (s: string) => {\n    let trimS = s.trim(),\n        left = trimS.length - 1,\n        right = trimS.length - 1,\n        words: Array<string> = []\n    while (left >= 0) {\n        while (left >= 0 && trimS[left] !== \" \") {\n            left--\n        }\n        words.push(trimS.slice(left + 1, right + 1))\n        while (left >= 0 && trimS[left] === \" \") {\n            left--\n        }\n        right = left\n    }\n    return words\n}\n\nfunction joinTokens(words: Array<string>) {\n    return words\n        .reduce((res, _cur) => {\n            return res + \" \" + _cur\n        }, \"\")\n        .trimStart()\n}\n\nfunction reverseWords(s: string): string {\n    return joinTokens(getTokens(s))\n}\n",
            "url": "https://leetcode.cn/problems/reverse-words-in-a-string/description/",
            "sortKey": 3
          },
          {
            "name": "4.实现strStr().ts",
            "type": "file",
            "path": "src/4.字符串/4.实现strStr().ts",
            "content": "/**\n * @url https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/\n * @description 实际考察kmp算法，// todo\n */\nfunction strStr(haystack: string, needle: string): number {\n    return haystack.indexOf(needle)\n}\n",
            "url": "https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/",
            "sortKey": 4
          },
          {
            "name": "5.重复的子字符串.ts",
            "type": "file",
            "path": "src/4.字符串/5.重复的子字符串.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/repeated-substring-pattern/description/\n */\nfunction repeatedSubstringPattern(s: string): boolean {\n    for (let i = 0; i < Math.floor(s.length / 2); i++) {\n        let len = Math.floor(s.length / s.slice(0, i + 1).length)\n        if (s.slice(0, i + 1).repeat(len) === s) return true\n    }\n    return false\n}\n",
            "url": "https://leetcode.cn/problems/repeated-substring-pattern/description/",
            "sortKey": 5
          }
        ],
        "sortKey": 4
      },
      {
        "name": "5.栈与队列",
        "type": "directory",
        "path": "src/5.栈与队列",
        "children": [
          {
            "name": "1.用栈实现队列.ts",
            "type": "file",
            "path": "src/5.栈与队列/1.用栈实现队列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/implement-queue-using-stacks/description/\n */\nclass MyQueue {\n    queue: Array<number>\n    constructor() {\n        this.queue = []\n    }\n\n    push(x: number): void {\n        this.queue.push(x)\n    }\n\n    pop(): number {\n        return this.queue.shift() || 0\n    }\n\n    peek(): number {\n        return this.queue.concat([]).shift() || 0\n    }\n\n    empty(): boolean {\n        return this.queue.length === 0\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n",
            "url": "https://leetcode.cn/problems/implement-queue-using-stacks/description/",
            "sortKey": 1
          },
          {
            "name": "2.用队列实现栈.ts",
            "type": "file",
            "path": "src/5.栈与队列/2.用队列实现栈.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/implement-stack-using-queues/description/\n */\n\nclass MyStack {\n    queue: Array<number>\n    constructor() {\n        this.queue = []\n    }\n\n    push(x: number): void {\n        this.queue.push(x)\n    }\n\n    pop(): number {\n        return this.queue.pop() || -1\n    }\n\n    top(): number {\n        return this.queue.concat([]).pop() || -1\n    }\n\n    empty(): boolean {\n        return this.queue.length === 0\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * var obj = new MyStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.empty()\n */\n",
            "url": "https://leetcode.cn/problems/implement-stack-using-queues/description/",
            "sortKey": 2
          },
          {
            "name": "3.有效的括号.ts",
            "type": "file",
            "path": "src/5.栈与队列/3.有效的括号.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/valid-parentheses/\n */\nfunction isValid(s: string): boolean {\n    let obj = {\n            \")\": \"(\",\n            \"}\": \"{\",\n            \"]\": \"[\",\n        },\n        stack: Array<string> = []\n    for (let i = 0; i < s.length; i++) {\n        if (obj[s[i]] && stack.length > 0) {\n            const top = stack[stack.length - 1]\n            if (top === obj[s[i]]) {\n                stack.pop()\n            } else {\n                stack.push(s[i])\n            }\n        } else {\n            stack.push(s[i])\n        }\n    }\n\n    return stack.length === 0\n}\n",
            "url": "https://leetcode.cn/problems/valid-parentheses/",
            "sortKey": 3
          },
          {
            "name": "4.删除字符串中的所有相邻重复项.ts",
            "type": "file",
            "path": "src/5.栈与队列/4.删除字符串中的所有相邻重复项.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/\n */\nfunction removeDuplicates(s: string): string {\n    const sArray = s.split(\"\")\n    let stack: Array<string> = []\n    for (let i = 0; i < sArray.length; i++) {\n        if (stack.length === 0) {\n            stack.push(sArray[i])\n        } else {\n            let top = stack[stack.length - 1]\n            // let top = stack.concat().pop() // todo 这样会超时\n            if (sArray[i] === top) {\n                stack.pop()\n            } else {\n                stack.push(sArray[i])\n            }\n        }\n    }\n    return stack.join(\"\")\n}\n// notice:超时我就不是很理解\n",
            "url": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/",
            "sortKey": 4
          },
          {
            "name": "5.逆波兰表达式求值.ts",
            "type": "file",
            "path": "src/5.栈与队列/5.逆波兰表达式求值.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/\n */\n\nconst operators = [\"+\", \"-\", \"*\", \"/\"]\ntype computeType = \"+\" | \"-\" | \"*\" | \"/\"\nconst compute = (operators: computeType, top1: string, top2: string) => {\n    switch (operators) {\n        case \"+\":\n            return String(Number(top1) + Number(top2))\n        case \"-\":\n            return String(Number(top1) - Number(top2))\n        case \"*\":\n            return String(Number(top1) * Number(top2))\n        case \"/\":\n            return String(Number.parseInt(String(Number(top1) / Number(top2)))) //notice: Math.floor向下取整,注意负数的形式。 -0.4 会取整为-1\n    }\n}\n\nfunction evalRPN(tokens: string[]): number {\n    let stack: Array<string> = [] // 存储栈\n    for (let i = 0; i < tokens.length; i++) {\n        console.log(\"tokens\", stack)\n\n        if (operators.includes(tokens[i])) {\n            if (stack.length < 2) {\n                stack.push(tokens[i])\n            } else {\n                const top2 = stack.pop()\n                const top1 = stack.pop()\n                stack.push(compute(tokens[i] as computeType, top1!, top2!))\n            }\n        } else {\n            stack.push(tokens[i])\n        }\n    }\n    return Number(stack.pop())\n}\n\n// console.log(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))\n// console.log(evalRPN([\"4\", \"13\", \"5\", \"/\", \"+\"]))\n",
            "url": "https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/",
            "sortKey": 5
          },
          {
            "name": "6.滑动窗口求最大值.todo.ts",
            "type": "file",
            "path": "src/5.栈与队列/6.滑动窗口求最大值.todo.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/sliding-window-maximum/description/\n */\n",
            "url": "https://leetcode.cn/problems/sliding-window-maximum/description/",
            "sortKey": 6
          },
          {
            "name": "7.前k个高频元素.todo.ts",
            "type": "file",
            "path": "src/5.栈与队列/7.前k个高频元素.todo.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/top-k-frequent-elements/description/\n */\n",
            "url": "https://leetcode.cn/problems/top-k-frequent-elements/description/",
            "sortKey": 7
          }
        ],
        "sortKey": 5
      },
      {
        "name": "6.二叉树",
        "type": "directory",
        "path": "src/6.二叉树",
        "children": [
          {
            "name": "1.二叉树的递归遍历.ts",
            "type": "file",
            "path": "src/6.二叉树/1.二叉树的递归遍历.ts",
            "content": "/**\n * @description 前序遍历\n * @url https://leetcode.cn/problems/binary-tree-preorder-traversal/description/\n *\n * @description 中序遍历\n * @url https://leetcode.cn/problems/binary-tree-inorder-traversal/description/\n *\n * @description 后序遍历\n * @url https://leetcode.cn/problems/binary-tree-postorder-traversal/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\n/** 前序遍历 */\nfunction preorderTraversal(root: TreeNode | null): number[] {\n    let stack: number[] = []\n    if (!root) return stack\n    stack.push(root.val)\n    stack.push(...preorderTraversal(root.left))\n    stack.push(...preorderTraversal(root.right))\n    return stack\n}\n\n/** 中序遍历 */\nfunction inorderTraversal(root: TreeNode | null): number[] {\n    let stack: number[] = []\n    if (!root) return stack\n    stack.push(...inorderTraversal(root.left))\n    stack.push(root.val)\n    stack.push(...inorderTraversal(root.right))\n    return stack\n}\n\n/** 后续遍历 */\nfunction postorderTraversal(root: TreeNode | null): number[] {\n    let stack: number[] = []\n    if (!root) return stack\n    stack.push(...postorderTraversal(root.left))\n    stack.push(...postorderTraversal(root.right))\n    stack.push(root.val)\n    return stack\n}\n",
            "url": "https://leetcode.cn/problems/binary-tree-preorder-traversal/description/",
            "sortKey": 1
          },
          {
            "name": "2.二叉树的迭代遍历.ts",
            "type": "file",
            "path": "src/6.二叉树/2.二叉树的迭代遍历.ts",
            "content": "/**\n * @description 迭代遍历\n * @url url是1中的\n */\n\n// notice:处理节点和遍历节点\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\nlet root = new TreeNode(1, null, new TreeNode(2, new TreeNode(3), null))\n\n/** 前序遍历 */\nfunction preorderTraversal(root: TreeNode | null): number[] {\n    let stack: Array<TreeNode | null> = [],\n        result: number[] = []\n    if (!root) return result\n    stack.push(root)\n    while (stack.length) {\n        let top = stack.pop()\n        if (top) {\n            result.push(top.val)\n            stack.push(top.right)\n            stack.push(top.left)\n        }\n    }\n    return result\n}\n\n/** 中序遍历 */\n// 左中右\n// TODO:可以再来尝试一下\nfunction inorderTraversal(root: TreeNode | null): number[] {\n    let stack: Array<TreeNode | null> = [],\n        result: number[] = []\n    if (!root) return result\n    while (root || stack.length !== 0) {\n        if (root) {\n            stack.push(root)\n            root = root?.left\n        } else {\n            let node = stack.pop()\n            root = node || null\n            if (node) {\n                result.push(node.val)\n            }\n            root = root?.right || null\n        }\n    }\n\n    return result\n}\n\n/** 后续遍历 */\n// TODO:先写前序，改变前序的顺序，然后反转前序遍历的数组\nfunction postorderTraversal(root: TreeNode | null): number[] {\n    let stack: Array<TreeNode | null> = [],\n        result: number[] = []\n    if (!root) return result\n    stack.push(root)\n    while (stack.length) {\n        let top = stack.pop()\n        if (top) {\n            result.push(top?.val)\n            stack.push(top.left)\n            stack.push(top.right)\n        }\n    }\n    return result.reverse()\n}\n",
            "url": "",
            "sortKey": 2
          },
          {
            "name": "3.二叉树的层序遍历.ts",
            "type": "file",
            "path": "src/6.二叉树/3.二叉树的层序遍历.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/binary-tree-level-order-traversal/description/\n */\n// 层序遍历用队列\nfunction levelOrder(root: TreeNode | null): number[][] {\n    let stack: Array<TreeNode | null> = [],\n        result: number[][] = []\n    if (!root) return result\n    stack.push(root)\n    while (stack.length) {\n        const copyStack = stack.concat([])\n        const res: number[] = []\n        for (let i = 0; i < copyStack.length; i++) {\n            const queue = stack.shift()\n            if (queue) {\n                res.push(queue.val)\n            }\n            if (queue?.left) {\n                stack.push(queue.left)\n            }\n            if (queue?.right) {\n                stack.push(queue.right)\n            }\n        }\n        result.push(res)\n    }\n    return result\n}\n\n/**\n * @url https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/\n */\nfunction levelOrderBottom(root: TreeNode | null): number[][] {\n    let stack: Array<TreeNode | null> = [],\n        result: number[][] = []\n    if (!root) return result\n    stack.push(root)\n    while (stack.length) {\n        let traverseStack = stack.concat(),\n            temRes: number[] = []\n        for (let i = 0; i < traverseStack.length; i++) {\n            let top = stack.shift()\n            if (top) {\n                temRes.push(top?.val)\n            }\n            if (top?.left) {\n                stack.push(top.left)\n            }\n            if (top?.right) {\n                stack.push(top.right)\n            }\n        }\n        result.push(temRes)\n    }\n    return result.reverse()\n}\n\n/**\n * @url https://leetcode.cn/problems/binary-tree-right-side-view/\n */\nfunction rightSideView(root: TreeNode | null): number[] {\n    let stack: Array<TreeNode | null> = [],\n        result: number[] = []\n    if (!root) return result\n    stack.push(root)\n    while (stack.length) {\n        let traverseStack = stack.concat(),\n            temRes: number[] = []\n        for (let i = 0; i < traverseStack.length; i++) {\n            let top = stack.shift()\n            if (top) {\n                temRes.push(top?.val)\n            }\n            if (top?.left) {\n                stack.push(top.left)\n            }\n            if (top?.right) {\n                stack.push(top.right)\n            }\n        }\n        result.push(temRes[temRes.length - 1])\n    }\n    return result\n}\n\n/**\n * @url https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/\n */\nfunction averageOfLevels(root: TreeNode | null): number[] {\n    let stack: Array<TreeNode | null> = [],\n        result: number[] = []\n    if (!root) return result\n    stack.push(root)\n    while (stack.length) {\n        let traverseStack = stack.concat(),\n            temRes: number[] = []\n        for (let i = 0; i < traverseStack.length; i++) {\n            let top = stack.shift()\n            if (top) {\n                temRes.push(top?.val)\n            }\n            if (top?.left) {\n                stack.push(top.left)\n            }\n            if (top?.right) {\n                stack.push(top.right)\n            }\n        }\n        result.push(\n            temRes.reduce((acc, cur) => {\n                return acc + cur\n            }, 0) / temRes.length\n        )\n    }\n    return result\n}\n\n/**\n * @url https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/\n */\n\n// class _Node {\n//     val: number\n//     children: _Node[]\n//     constructor(v: number) {\n//         this.val = v\n//         this.children = []\n//     }\n// }\n\n// function levelOrderN(root: _Node | null): number[][] {\n//     let stack: Array<_Node | null> = [],\n//         result: number[][] = []\n//     if (!root) return result\n//     stack.push(root)\n//     while (stack.length) {\n//         let traverseStack = stack.concat(),\n//             temRes: number[] = []\n//         for (let i = 0; i < traverseStack.length; i++) {\n//             let top = stack.shift()\n//             if (top) {\n//                 temRes.push(top?.val)\n//             }\n//             if (top?.children.length) {\n//                 top.children.forEach((_childNode) => {\n//                     stack.push(_childNode)\n//                 })\n//             }\n//         }\n//         result.push(temRes)\n//     }\n//     return result\n// }\n\n/**\n * @description 在每个树行中找最大值\n * @url https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/\n */\n\nfunction largestValues(root: TreeNode | null): number[] {\n    let stack: Array<TreeNode | null> = [],\n        result: number[] = []\n    if (!root) return result\n    stack.push(root)\n    while (stack.length) {\n        let traverseStack = stack.concat(),\n            temRes: number[] = []\n        for (let i = 0; i < traverseStack.length; i++) {\n            let top = stack.shift()\n            if (top) {\n                temRes.push(top?.val)\n            }\n            if (top?.left) {\n                stack.push(top.left)\n            }\n            if (top?.right) {\n                stack.push(top.right)\n            }\n        }\n        result.push(Math.max(...temRes))\n    }\n    return result\n}\n\nclass _Node {\n    val: number\n    left: _Node | null\n    right: _Node | null\n    next: _Node | null\n    constructor(val?: number, left?: _Node, right?: _Node, next?: _Node) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n        this.next = next === undefined ? null : next\n    }\n}\n/**\n * @description 填充每个节点的下一个右侧节点指针\n * @url https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/\n */\nfunction connect(root: _Node | null): _Node | null {\n    let stack: Array<_Node | null> = []\n    if (!root) return root\n    stack.push(root)\n    while (stack.length) {\n        let tempQueue = stack.concat()\n        for (let i = 0; i < tempQueue.length; i++) {\n            let _node = stack.shift()\n            if (tempQueue.length !== 1) {\n                if (i !== tempQueue.length - 1) {\n                    _node!.next = stack[0]\n                }\n            }\n            if (_node?.left) {\n                stack.push(_node?.left)\n            }\n            if (_node?.right) {\n                stack.push(_node?.right)\n            }\n        }\n    }\n    return root\n}\n\n/**\n * @description 最大深度\n * @url https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/\n */\nfunction maxDepth(root: TreeNode | null): number {\n    let stack: Array<TreeNode | null> = [],\n        depth = 0\n    if (!root) return depth\n    stack.push(root)\n    while (stack.length) {\n        let tempStack = stack.concat()\n        for (let i = 0; i < tempStack.length; i++) {\n            let node = stack.pop()\n            node?.left && stack.push(node.left)\n            node?.right && stack.push(node.right)\n        }\n        depth += 1\n    }\n    return depth\n}\n\n/**\n * @description 最小深度\n * @url https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/\n */\nfunction minDepth(root: TreeNode | null): number {\n    let stack: Array<TreeNode | null> = [],\n        depth = 0\n    if (!root) return depth\n    stack.push(root)\n\n    while (stack.length) {\n        let tempStack = stack.concat()\n        let flag = false\n        for (let i = 0; i < tempStack.length; i++) {\n            let node = stack.shift()\n\n            if (!node?.left && !node?.right) {\n                flag = true\n            }\n\n            node?.left && stack.push(node.left)\n            node?.right && stack.push(node.right)\n        }\n        depth += 1\n\n        if (flag) {\n            return depth\n        }\n    }\n    return depth\n}\n",
            "url": "https://leetcode.cn/problems/binary-tree-level-order-traversal/description/",
            "sortKey": 3
          },
          {
            "name": "4.翻转二叉树.ts",
            "type": "file",
            "path": "src/6.二叉树/4.翻转二叉树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/invert-binary-tree/description/\n */\n\nimport { rootCertificates } from \"tls\"\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\nfunction invertTree(root: TreeNode | null): TreeNode | null {\n    if (!root) return null\n    if (root) {\n        let p = root.left\n        root.left = root.right\n        root.right = p\n        invertTree(root.left)\n        invertTree(root.right)\n    }\n    return root\n}\n",
            "url": "https://leetcode.cn/problems/invert-binary-tree/description/",
            "sortKey": 4
          },
          {
            "name": "5.对称二叉树.ts",
            "type": "file",
            "path": "src/6.二叉树/5.对称二叉树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/symmetric-tree/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\n// notice:compare比较单个单点的函数，然后比较左子树，右子树的节点\n\nfunction isSymmetric(root: TreeNode | null): boolean {\n    const compare = (left: TreeNode | null, right: TreeNode | null) => {\n        const specialCondition = (left && !right) || (!left && right)\n        const empty = !left && !right\n        if (specialCondition) {\n            return false\n        }\n        if (empty) {\n            return true\n        }\n        if (left?.val !== right?.val) {\n            return false\n        }\n        const inSide = compare(left!.left, right!.right)\n        const outSide = compare(left!.right, right!.left)\n        return inSide && outSide\n    }\n    if (!root) return true\n    return compare(root.left, root.right)\n}\n\n/**\n * @description 相同的树\n * @url https://leetcode.cn/problems/same-tree/\n */\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    const compare = (p: TreeNode | null, q: TreeNode | null) => {\n        // 比较单节点\n        const special = (!p && q) || (p && !q)\n        if (special) return false\n        const isEmpty = !p && !q\n        if (isEmpty) return true\n        if (p?.val !== q?.val) return false\n        // 比较子树\n        return compare(p!.left, q!.left) && compare(p!.right, q!.right)\n    }\n    return compare(p, q)\n}\n\n/**\n * @description 另一个树的子树\n * @url https://leetcode.cn/problems/subtree-of-another-tree/description/\n */\n\n// compare比较根节点相同的两个子树是否相同\nconst compare = (root: TreeNode | null, subRoot: TreeNode | null) => {\n    const specialCondition = (root && !subRoot) || (!root && subRoot)\n    const empty = !root && !subRoot\n    if (specialCondition) {\n        return false\n    }\n    if (empty) {\n        return true\n    }\n    if (root?.val !== subRoot?.val) {\n        return false\n    }\n    return compare(root!.left, subRoot!.left) && compare(root!.right, subRoot!.right)\n}\nfunction isSubtree(root: TreeNode | null, subRoot: TreeNode | null): boolean {\n    // 对root进行dfs的遍历\n    if (!root) return false\n    return compare(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)\n}\n",
            "url": "https://leetcode.cn/problems/symmetric-tree/description/",
            "sortKey": 5
          },
          {
            "name": "6.二叉树的最大深度.ts",
            "type": "file",
            "path": "src/6.二叉树/6.二叉树的最大深度.ts",
            "content": "/**\n * @description 递归法\n * @url https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\n// 自上而下求深度\nfunction maxDepth(root: TreeNode | null): number {\n    const dfs = (root, depth) => {\n        if (!root) return depth\n        return Math.max(dfs(root.left, depth + 1), dfs(root.right, depth + 1))\n    }\n    return dfs(root, 0)\n}\n// 自下而上求高度\nfunction maxDepthDeep(root: TreeNode | null): number {\n    const dfs = (root) => {\n        if (!root) return 0\n        return 1 + Math.max(dfs(root.left), dfs(root.right))\n    }\n    return dfs(root)\n}\n",
            "url": "https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/",
            "sortKey": 6
          },
          {
            "name": "7.二叉树的最小深度.ts",
            "type": "file",
            "path": "src/6.二叉树/7.二叉树的最小深度.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/\n */\n\n// TODO:有特殊case，单链表类型的特殊case\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\n// 通过计算高度来算的\nfunction minDepth(root: TreeNode | null): number {\n    const dfs = (root: TreeNode | null) => {\n        if (!root) return 0\n        if (!root.left && root.right) {\n            return 1 + dfs(root.right)\n        }\n        if (root.left && !root.right) {\n            return 1 + dfs(root.left)\n        }\n        return 1 + Math.min(dfs(root.left), dfs(root.right))\n    }\n    return dfs(root)\n}\n\n// 通过深度来计算\nfunction minDepthTwo(root: TreeNode | null): number {\n    const dfs = (root: TreeNode | null, depth) => {\n        if (!root) return 0\n        if (!root.left && root.right) {\n            return dfs(root.right, depth + 1)\n        }\n        if (root.left && !root.right) {\n            return dfs(root.left, depth + 1)\n        }\n        return Math.min(dfs(root.left, depth + 1), dfs(root.right, depth + 1))\n    }\n    return dfs(root, 0)\n}\n",
            "url": "https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/",
            "sortKey": 7
          },
          {
            "name": "8.完全二叉树的节点个数.ts",
            "type": "file",
            "path": "src/6.二叉树/8.完全二叉树的节点个数.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/count-complete-tree-nodes/description/\n * @videoUrl https://www.bilibili.com/video/BV1eW4y1B7pD/?spm_id_from=333.788&vd_source=1c79b7395f5d242a2f6786026aac6213\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\n// TODO:完全二叉树和满二叉树的概念\n\nfunction countNodes(root: TreeNode | null): number {\n    if (!root) {\n        // console.log(leftDepth, rightDepth)\n        return 0\n    }\n\n    let left = root.left,\n        right = root.right,\n        leftDepth = 1,\n        rightDepth = 1\n    while (left) {\n        left = left.left\n        leftDepth++\n    }\n    while (right) {\n        right = right.right\n        rightDepth++\n    }\n    if (leftDepth === rightDepth) {\n        if (leftDepth !== 1) {\n            return 2 ** leftDepth - 1\n        }\n        return 1\n    }\n\n    return 1 + countNodes(root.left) + countNodes(root.right)\n}\n\n// let root = new TreeNode(1)\n// console.log(countNodes(root))\n",
            "url": "https://leetcode.cn/problems/count-complete-tree-nodes/description/",
            "sortKey": 8
          },
          {
            "name": "9.平衡二叉树.ts",
            "type": "file",
            "path": "src/6.二叉树/9.平衡二叉树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/balanced-binary-tree/description/\n * @videoUrl https://www.bilibili.com/video/BV1Ug411S7my/?spm_id_from=333.788&vd_source=1c79b7395f5d242a2f6786026aac6213\n */\n\n// TODO:准备二刷了（高度和深度的理解）\n// 这题只能求高度\nfunction isBalanced(root: TreeNode | null): boolean {\n    const dfs = (root: TreeNode | null) => {\n        if (!root) return 0\n        // notice:单层递归的逻辑\n        let leftHeight = dfs(root.left)\n        if (leftHeight === -1) {\n            return -1\n        }\n        let rightHeight = dfs(root.right)\n        if (rightHeight === -1) {\n            return -1\n        }\n        return Math.abs(leftHeight - rightHeight) > 1 ? -1 : Math.max(leftHeight, rightHeight) + 1\n    }\n    if (!root) return true\n    return dfs(root) !== -1\n}\n",
            "url": "https://leetcode.cn/problems/balanced-binary-tree/description/",
            "sortKey": 9
          },
          {
            "name": "10.二叉树的所有路径.ts",
            "type": "file",
            "path": "src/6.二叉树/10.二叉树的所有路径.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/binary-tree-paths/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\nfunction binaryTreePaths(root: TreeNode | null): string[] {\n    let path: Array<string> = []\n    const dfs = (root: TreeNode | null | undefined, pathTempArray: Array<string>) => {\n        if (!root) return\n        pathTempArray.push(String(root?.val))\n\n        if (!root?.left && !root?.right) {\n            path.push(pathTempArray.join(\"->\"))\n            return\n        }\n        dfs(root?.left, pathTempArray.concat())\n        dfs(root?.right, pathTempArray.concat())\n    }\n    dfs(root, [])\n    return path\n}\n",
            "url": "https://leetcode.cn/problems/binary-tree-paths/description/",
            "sortKey": 10
          },
          {
            "name": "11.左叶子之和.ts",
            "type": "file",
            "path": "src/6.二叉树/11.左叶子之和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/sum-of-left-leaves/description/\n */\n\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction sumOfLeftLeaves(root: TreeNode | null): number {\n  let sum = 0;\n  const dfs = (root: TreeNode | null | undefined) => {\n    if (!root) return;\n    if (root.left && !root.left.left && !root.left.right) {\n      sum += root.left.val;\n      // return\n      // PS:notice：这里容易return掉\n    }\n    dfs(root.left);\n    dfs(root.right);\n  };\n  dfs(root);\n  return sum;\n}\n\n// ;[3, 9, 20, null, null, 15, 7]\n\nlet root = new TreeNode(\n  3,\n  new TreeNode(9),\n  new TreeNode(20, new TreeNode(15), new TreeNode(7))\n);\nconsole.log(sumOfLeftLeaves(root));\n",
            "url": "https://leetcode.cn/problems/sum-of-left-leaves/description/",
            "sortKey": 11
          },
          {
            "name": "12.找树左下角的值.ts",
            "type": "file",
            "path": "src/6.二叉树/12.找树左下角的值.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/find-bottom-left-tree-value/description/\n */\n\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction findBottomLeftValue(root: TreeNode | null): number {\n  let maxDepth = Number.MIN_SAFE_INTEGER,\n    res;\n  const dfs = (root: TreeNode | null | undefined, depth) => {\n    if (!root) return -1;\n    if (!root.left && !root.right) {\n      if (maxDepth < depth) {\n        maxDepth = depth;\n        res = root.val;\n        return;\n      }\n    }\n    // 找最左下角的值，所以先遍历左边，然后先判断下手为强\n    dfs(root.left, depth + 1);\n    dfs(root.right, depth + 1);\n  };\n  dfs(root, 1);\n  return res;\n}\n\n// 层序遍历去做，不过会超时\n// function findBottomLeftValue(root: TreeNode | null): number {\n//     let val  = 0;\n//     const stack = []\n//     stack.push(root)\n//     while(stack.length){\n//         let copyStack = stack.concat()\n//         console.log(copyStack)\n//         for(let i = 0; i < copyStack.length; i++){\n//             const top = stack.shift()\n//             if(i === 0){\n//                 val = top.val\n//             }\n//             if(top?.left){\n//                 stack.push(top.left)\n//             }\n//             if(top?.right){\n//                 stack.push(top.right)\n//             }\n//         }\n//     }\n//     return val\n// };\n",
            "url": "https://leetcode.cn/problems/find-bottom-left-tree-value/description/",
            "sortKey": 12
          },
          {
            "name": "13.路径总和.ts",
            "type": "file",
            "path": "src/6.二叉树/13.路径总和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/path-sum/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\nfunction hasPathSum(root: TreeNode | null, targetSum: number): boolean {\n    const dfs = (root: TreeNode | null, sum) => {\n        if (!root) {\n            // 这里返回什么都无所谓，主要是return 掉\n            return 0\n        }\n        if (!root.left && !root.right) {\n            sum += root.val\n            if (sum === targetSum) {\n                return true\n            } else {\n                return false\n            }\n        }\n\n        return dfs(root.left, sum + root.val) || dfs(root.right, sum + root.val)\n    }\n    return dfs(root, 0)\n}\n",
            "url": "https://leetcode.cn/problems/path-sum/description/",
            "sortKey": 13
          },
          {
            "name": "14.从中序与后序遍历序列构造二叉树.ts",
            "type": "file",
            "path": "src/6.二叉树/14.从中序与后序遍历序列构造二叉树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/\n * @videoUrl https://www.bilibili.com/video/BV1vW4y1i7dn/?vd_source=1c79b7395f5d242a2f6786026aac6213\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\nfunction buildTree(inorder: number[], postorder: number[]): TreeNode | null {\n    if (postorder.length === 0) return null\n    let midValue = postorder.pop()\n    const root = new TreeNode(midValue)\n    let _index = inorder.indexOf(midValue!)\n    root.left = buildTree(inorder.slice(0, _index), postorder.slice(0, _index)) // notice：注意中间节点需要去掉\n    root.right = buildTree(inorder.slice(_index + 1), postorder.slice(_index))\n    return root\n}\n\n/**\n * @description 从前序与中序遍历序列构造二叉树\n * @url https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/\n */\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n    if (preorder.length === 0) return null\n    let _mid = preorder.shift() // notice:一定要注意！！！真的闹糊涂了\n    let _root = new TreeNode(_mid)\n    let _index = inorder.indexOf(_mid!)\n    _root.left = buildTree(preorder.slice(0, _index), inorder.slice(0, _index))\n    _root.right = buildTree(preorder.slice(_index), inorder.slice(_index + 1))\n    return _root\n}\n",
            "url": "https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/",
            "sortKey": 14
          },
          {
            "name": "15.最大二叉树.ts",
            "type": "file",
            "path": "src/6.二叉树/15.最大二叉树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/maximum-binary-tree/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\nfunction constructMaximumBinaryTree(nums: number[]): TreeNode | null {\n    if (nums.length === 0) return null\n    if (nums.length === 1) return new TreeNode(nums[0])\n    let _maxIdx = nums.indexOf(Math.max(...nums))\n    let _root = new TreeNode(nums[_maxIdx])\n    _root.left = constructMaximumBinaryTree(nums.slice(0, _maxIdx))\n    _root.right = constructMaximumBinaryTree(nums.slice(_maxIdx + 1))\n    return _root\n}\n",
            "url": "https://leetcode.cn/problems/maximum-binary-tree/description/",
            "sortKey": 15
          },
          {
            "name": "16.合并二叉树.ts",
            "type": "file",
            "path": "src/6.二叉树/16.合并二叉树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/merge-two-binary-trees/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\nfunction mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {\n    if (!root1 && !root2) {\n        return null\n    }\n    if (!root1) return root2\n    if (!root2) return root1\n    root1.left = mergeTrees(root1.left, root2.left)\n    root1.right = mergeTrees(root1.right, root2.right)\n    root1.val += root2.val\n\n    return root1\n}\n",
            "url": "https://leetcode.cn/problems/merge-two-binary-trees/description/",
            "sortKey": 16
          },
          {
            "name": "17.二叉搜索树的搜索.ts",
            "type": "file",
            "path": "src/6.二叉树/17.二叉搜索树的搜索.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/search-in-a-binary-search-tree/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n// TODO:注意二叉搜索树的特性\n/** 暴力法 */\nfunction searchBST(root: TreeNode | null, val: number): TreeNode | null {\n    const dfs = (root: TreeNode | null | undefined) => {\n        if (!root) return null\n\n        if (root.left) {\n            const res = dfs(root.left)\n            if (res) {\n                return res\n            }\n        }\n\n        if (root.val === val) {\n            return root\n        }\n        if (root.right) {\n            const res = dfs(root.right)\n            if (res) {\n                return res\n            }\n        }\n        return null\n    }\n    return dfs(root)\n}\n\n/** 利用二叉搜索树的特性法 */\nfunction searchBSTDeep(root: TreeNode | null, val: number): TreeNode | null {\n    const dfs = (root: TreeNode | null | undefined) => {\n        if (!root) return null\n\n        if (root.val === val) {\n            return root\n        } else if (root.val < val && root.right) {\n            const res = dfs(root.right)\n            if (res) {\n                return res\n            }\n        } else {\n            if (root.left) {\n                const res = dfs(root.left)\n                if (res) {\n                    return res\n                }\n            }\n        }\n\n        return null\n    }\n    return dfs(root)\n}\n",
            "url": "https://leetcode.cn/problems/search-in-a-binary-search-tree/",
            "sortKey": 17
          },
          {
            "name": "18.验证二叉搜索树.ts",
            "type": "file",
            "path": "src/6.二叉树/18.验证二叉搜索树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/validate-binary-search-tree/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\n// TODO:细节挺多的\nfunction isValidBST(root: TreeNode | null): boolean {\n    let last: TreeNode\n    const dfs = (root: TreeNode | null | undefined) => {\n        if (!root) return true\n        const left = dfs(root.left)\n        if (last && root.val <= last.val) return false\n        last = root\n        const right = dfs(root.right)\n        return left && right\n    }\n    return dfs(root)\n}\n",
            "url": "https://leetcode.cn/problems/validate-binary-search-tree/",
            "sortKey": 18
          },
          {
            "name": "19.二叉搜索树的最小绝对值差.ts",
            "type": "file",
            "path": "src/6.二叉树/19.二叉搜索树的最小绝对值差.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\nfunction getMinimumDifference(root: TreeNode | null): number {\n    let pre: TreeNode,\n        res = Number.MAX_SAFE_INTEGER\n    const dfs = (root: TreeNode | null | undefined) => {\n        if (!root) return Number.MAX_SAFE_INTEGER\n        dfs(root.left)\n        if (pre) {\n            res = Math.min(Math.abs(root.val - pre.val), res)\n        }\n        pre = root\n        dfs(root.right)\n        return res\n    }\n    return dfs(root)\n}\n",
            "url": "https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/",
            "sortKey": 19
          },
          {
            "name": "20.二叉搜索树的众数.ts",
            "type": "file",
            "path": "src/6.二叉树/20.二叉搜索树的众数.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\n// TODO:有坑\nfunction findMode(root: TreeNode | null): number[] {\n    let res: number[] = [],\n        maxCount = Number.MIN_SAFE_INTEGER,\n        prev: TreeNode | null | undefined,\n        curCount = 0\n\n    const dfs = (root: TreeNode | null | undefined) => {\n        if (!root) return\n        dfs(root.left)\n        if (prev && root.val === prev.val) {\n            curCount++\n            if (curCount === maxCount) {\n                res.push(root.val)\n            } else if (curCount > maxCount) {\n                res = []\n                res.push(root.val)\n                maxCount = curCount\n            }\n        } else {\n            curCount = 1\n        }\n        if (!prev) {\n            res.push(root.val)\n        }\n        prev = root\n\n        dfs(root.right)\n    }\n    dfs(root)\n    return res\n}\n\n// 构造二叉树\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n    let _mid = preorder.shift() // notice:一定要注意！！！真的闹糊涂了\n    if (preorder.length === 0) return null\n    let _root = new TreeNode(_mid)\n    let _index = inorder.indexOf(_mid!)\n    _root.left = buildTree(preorder.slice(0, _index), inorder.slice(0, _index))\n    _root.right = buildTree(preorder.slice(_index), inorder.slice(_index + 1))\n    return _root\n}\n\nconst root = buildTree([1, 2], [1, 2])\nconsole.log(root)\n",
            "url": "https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/",
            "sortKey": 20
          },
          {
            "name": "21.二叉树的最近公共祖先.ts",
            "type": "file",
            "path": "src/6.二叉树/21.二叉树的最近公共祖先.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\n// notice:后序遍历将结果返回上去，最后返回最终结果！\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n    if (!root) return null\n    if (root === q || root === p) return root\n    const left = lowestCommonAncestor(root.left, p, q)\n    const right = lowestCommonAncestor(root.right, p, q)\n    if (left && !right) {\n        return left\n    }\n    if (!left && right) {\n        return right\n    }\n    if (left && right) {\n        return root\n    }\n    return null\n}\n",
            "url": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/",
            "sortKey": 21
          },
          {
            "name": "22.二叉搜索树的最近公共祖先.ts",
            "type": "file",
            "path": "src/6.二叉树/22.二叉搜索树的最近公共祖先.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/\n */\n\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n    if (!root) return null\n    if (root === q || root === p) return root\n\n    if (root.val > p!.val && root.val > q!.val) {\n        const left = lowestCommonAncestor(root.left, p, q)\n        if (left) {\n            return left\n        }\n    }\n    if (root.val < p!.val && root.val < q!.val) {\n        const right = lowestCommonAncestor(root.right, p, q)\n        if (right) {\n            return right\n        }\n    }\n    const left = lowestCommonAncestor(root.left, p, q)\n    const right = lowestCommonAncestor(root.right, p, q)\n    if (!left && right) return right\n    if (left && !right) return left\n    if (left && right) return root\n    return null\n}\n",
            "url": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/",
            "sortKey": 22
          },
          {
            "name": "23.二叉搜索树的插入操作.ts",
            "type": "file",
            "path": "src/6.二叉树/23.二叉搜索树的插入操作.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/\n */\n\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n// function insertIntoBST(root: TreeNode | null, val: number): TreeNode | null {\n//     const dfs = (root: TreeNode | null, val: number) => {\n//         if (!root) {\n//             return\n//         }\n//         if (!root.left && !root.right) {\n//             // TODO:这样没有返回值的算法，会丢失掉左子树全为空的情况\n//             if (root.val > val) {\n//                 root.left = new TreeNode(val)\n//             } else {\n//                 root.right = new TreeNode(val)\n//             }\n//             return null\n//         }\n//         if (root.val > val) {\n//             dfs(root.left, val)\n//         }\n//         if (root.val < val) {\n//             dfs(root.right, val)\n//         }\n//     }\n//     if (!root) return new TreeNode(val)\n//     dfs(root, val)\n//     return root\n// }\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n// //========\n/**\n * @param {TreeNode} root\n * @param {number} val\n * @return {TreeNode}\n */\nvar insertIntoBST = function (root, val) {\n  const dfs = (root) => {\n    if (!root) return new TreeNode(val);\n    if (root.val > val) {\n      const left = dfs(root.left);\n      root.left = left;\n    } else {\n      const right = dfs(root.right);\n      root.right = right;\n    }\n    return root;\n  };\n  return dfs(root);\n};\n",
            "url": "https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/",
            "sortKey": 23
          },
          {
            "name": "24.删除二叉搜索树的节点.ts",
            "type": "file",
            "path": "src/6.二叉树/24.删除二叉搜索树的节点.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/delete-node-in-a-bst/description/\n */\n\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\n// notice\n// 总共有五种情况\n// 叶子节点，直接删掉就可以\n// 没有找到节点\n// 删除的节点只有左孩子，没有右孩子\n// 删除的节点只有右孩子，没有左孩子\n// 删除的节点既有右孩子，也有左孩子\nfunction deleteNode(root: TreeNode | null, key: number): TreeNode | null {\n  if (!root) return null;\n  if (root.val === key) {\n    if (!root.left && !root.right) {\n      return null;\n    }\n    if (root.left && !root.right) {\n      return root.left;\n    }\n    if (!root.left && root.right) {\n      return root.right;\n    }\n    if (root.left && root.right) {\n      let cur = root.right;\n      while (cur.left) {\n        cur = cur.left;\n      }\n      cur.left = root.left;\n      return root.right;\n    }\n  }\n\n  if (root.val > key) {\n    root.left = deleteNode(root.left, key);\n  } else {\n    root.right = deleteNode(root.right, key);\n  }\n  return root;\n}\n",
            "url": "https://leetcode.cn/problems/delete-node-in-a-bst/description/",
            "sortKey": 24
          },
          {
            "name": "25.修剪二叉搜素树.ts",
            "type": "file",
            "path": "src/6.二叉树/25.修剪二叉搜素树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/trim-a-binary-search-tree/description/\n */\n\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n// TODO: 如果直接返回左右子树的话，没有考虑左右子树里面还有不符合条件的子树\n/**\n * 沿用上一题的思路稍微改一下就可以了。上一题只需要删除一个结点,然后直接return,导致其下面还符合条件的结点没法删除。原因是因为上一题实\n   际上是个先序遍历,符合条件直接return,如果我们改为后序遍历就可以了,每次判定都会是最底下的结点先判定,也就是把判断的代码写到递归代码  \n   的后面。\n */\nfunction trimBST(\n  root: TreeNode | null,\n  low: number,\n  high: number\n): TreeNode | null {\n  if (!root) return null;\n\n  // 先处理子树里面的子树,这里的遍历顺序有一定的讲究。\n  root.left = trimBST(root.left, low, high); // 需要先将左子树进行修剪。\n  root.right = trimBST(root.right, low, high); // 需要将右子树进行修剪。\n\n  if (root.val < low || root.val > high) {\n    if (!root.left && !root.right) {\n      return null;\n    }\n    if (root.left && !root.right) {\n      return root.left;\n    }\n    if (!root.left && root.right) {\n      return root.right;\n    }\n    if (root.left && root.right) {\n      let cur = root.right;\n      while (cur.left) {\n        cur = cur.left;\n      }\n      cur.left = root.left;\n      return root.right;\n    }\n  }\n  return root;\n}\n",
            "url": "https://leetcode.cn/problems/trim-a-binary-search-tree/description/",
            "sortKey": 25
          },
          {
            "name": "26.将有序数组转换为二叉搜索树.ts",
            "type": "file",
            "path": "src/6.二叉树/26.将有序数组转换为二叉搜索树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/\n */\n\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction sortedArrayToBST(nums: number[]): TreeNode | null {\n  if (nums.length === 0) return null;\n  let mid = Math.floor(nums.length / 2);\n  let root = new TreeNode(nums[mid]);\n  root.left = sortedArrayToBST(nums.slice(0, mid));\n  root.right = sortedArrayToBST(nums.slice(mid + 1));\n  return root;\n}\n",
            "url": "https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/",
            "sortKey": 26
          },
          {
            "name": "27.把二叉搜索树转换为累加树.ts",
            "type": "file",
            "path": "src/6.二叉树/27.把二叉搜索树转换为累加树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/convert-bst-to-greater-tree/description/\n */\n\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nfunction sortedArrayToBST(nums: number[]): TreeNode | null {\n  if (nums.length === 0) return null;\n  let mid = Math.floor(nums.length / 2);\n  let root = new TreeNode(nums[mid]);\n  root.left = sortedArrayToBST(nums.slice(0, mid));\n  root.right = sortedArrayToBST(nums.slice(mid + 1));\n  return root;\n}\n\n// TODO:一种是维护全局的一个sum。代表累加的值   一种是用prev指针来指向上一个遍历的指针。\nfunction convertBST(root: TreeNode | null): TreeNode | null {\n  let sum = 0;\n  const dfs = (root: TreeNode | null) => {\n    if (!root) return 0;\n    dfs(root.right);\n    sum += root.val;\n    root.val = sum;\n    dfs(root.left);\n  };\n  dfs(root);\n  return root;\n}\n\nconst rootArray = [1, 2, 3, 4, 5, 6, 7, 8];\nconst root = sortedArrayToBST(rootArray);\nconsole.log(convertBST(root));\n",
            "url": "https://leetcode.cn/problems/convert-bst-to-greater-tree/description/",
            "sortKey": 27
          }
        ],
        "sortKey": 6
      },
      {
        "name": "7.回溯算法",
        "type": "directory",
        "path": "src/7.回溯算法",
        "children": [
          {
            "name": "1.组合.ts",
            "type": "file",
            "path": "src/7.回溯算法/1.组合.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/combinations/description/\n */\n\n// TODO:后期关于回溯的题目，统一看看是否能够剪枝。\nfunction combine(n: number, k: number): number[][] {\n    const result: Array<Array<number>> = []\n    const traceBacking = (idx: number, acc: number[]) => {\n        if (acc.length === k) {\n            result.push(acc)\n            return\n        }\n\n        for (let i = idx; i <= n; i++) {\n            acc.push(i)\n            traceBacking(i + 1, acc.concat([]))\n            acc.pop()\n        }\n    }\n    traceBacking(1, [])\n    return result\n}\n",
            "url": "https://leetcode.cn/problems/combinations/description/",
            "sortKey": 1
          },
          {
            "name": "2.组合总和三.ts",
            "type": "file",
            "path": "src/7.回溯算法/2.组合总和三.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/combination-sum-iii/description/\n */\n\nfunction combinationSum3(k: number, n: number): number[][] {\n    const result: number[][] = []\n    const dfs = (idx: number, path: number[]) => {\n        if (path.length === k) {\n            if (path.reduce((acc, cur) => acc + cur, 0) === n) {\n                result.push(path)\n            }\n            return\n        }\n        for (let i = idx + 1; i <= 9; i++) {\n            path.push(i)\n            dfs(i, path.concat([]))\n            path.pop()\n        }\n    }\n    dfs(0, [])\n    return result\n}\n",
            "url": "https://leetcode.cn/problems/combination-sum-iii/description/",
            "sortKey": 2
          },
          {
            "name": "3.电话号码的字母组合.ts",
            "type": "file",
            "path": "src/7.回溯算法/3.电话号码的字母组合.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/\n */\n\nfunction init(): Map<string, string> {\n    let map = new Map()\n    map.set(\"2\", \"abc\")\n    map.set(\"3\", \"def\")\n    map.set(\"4\", \"ghi\")\n    map.set(\"5\", \"jkl\")\n    map.set(\"6\", \"mno\")\n    map.set(\"7\", \"pqrs\")\n    map.set(\"8\", \"tuv\")\n    map.set(\"9\", \"wxyz\")\n    return map\n}\nfunction letterCombinations(digits: string): string[] {\n    const result: string[] = []\n    const map = init()\n    const dfs = (path: string[], idx: number) => {\n        if (path.length === digits.length) {\n            result.push(path.join(\"\"))\n            return\n        }\n        const str = map.get(digits[idx])\n        for (let i = 0; i < str!.length; i++) {\n            path.push(str![i])\n            dfs(path.concat([]), idx + 1)\n            path.pop()\n        }\n    }\n    dfs([], 0)\n    return result.filter((_str) => _str !== \"\")\n}\n// console.log(letterCombinations(\"23\"))\n",
            "url": "https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/",
            "sortKey": 3
          },
          {
            "name": "4.组合总和.ts",
            "type": "file",
            "path": "src/7.回溯算法/4.组合总和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/combination-sum/description/\n */\n\n// notice：没有去重操作，用Set来进行去重\n// function combinationSum(candidates: number[], target: number): number[][] {\n//     const result: number[][] = []\n//     const set = new Set()\n//     const dfs = (path: number[]) => {\n//         const sum = path.reduce((acc, cur) => acc + cur, 0)\n//         if (sum > target) {\n//             return\n//         }\n//         if (sum === target) {\n//             set.add(JSON.stringify(path.sort((a, b) => a - b)))\n//             return\n//         }\n//         for (let idx = 0; idx < candidates.length; idx++) {\n//             path.push(candidates[idx])\n//             dfs(path.concat())\n//             path.pop()\n//         }\n//     }\n//     dfs([])\n\n//     for (let item of set) {\n//         result.push(JSON.parse(item as string))\n//     }\n//     return result\n// }\n// 去重操作，在traverse的时候进行去重 // ps:利用startIdx来去进行去重\nfunction combinationSum(candidates: number[], target: number): number[][] {\n  const res: number[][] = [];\n  const dfs = (idx: number, path: number[]) => {\n    const sum = path.reduce((acc, cur) => acc + cur, 0);\n    if (sum > target) {\n      return;\n    }\n    if (sum === target) {\n      res.push(path);\n      return;\n    }\n    for (let i = idx; i < candidates.length; i++) {\n      path.push(candidates[i]);\n      dfs(i, path.concat([]));\n      path.pop();\n    }\n  };\n  dfs(0, []);\n  return res;\n}\n",
            "url": "https://leetcode.cn/problems/combination-sum/description/",
            "sortKey": 4
          },
          {
            "name": "5.组合总和2.ts",
            "type": "file",
            "path": "src/7.回溯算法/5.组合总和2.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/combination-sum-ii/description/\n */\n// PS:难点去重\nfunction combinationSum2(candidates: number[], target: number): number[][] {\n  const result: Array<Array<number>> = [];\n  const used: Array<boolean> = new Array(candidates.length).fill(false);\n  candidates.sort((a, b) => a - b); // ps:这里排序的意义是防止后面有与前面相同的元素\n  const dfs = (startIdx, path) => {\n    const sum = path.reduce((acc, cur) => acc + cur, 0);\n    if (sum === target) {\n      result.push(path);\n      return;\n    }\n    if (sum > target) {\n      return;\n    }\n    for (let i = startIdx; i < candidates.length; i++) {\n      if (i > 0 && candidates[i] === candidates[i - 1] && !used[i - 1]) {\n        continue;\n      }\n      used[i] = true;\n      path.push(candidates[i]);\n      dfs(i + 1, path.concat([]));\n      path.pop();\n      used[i] = false;\n    }\n  };\n  dfs(0, []);\n  return result;\n}\n",
            "url": "https://leetcode.cn/problems/combination-sum-ii/description/",
            "sortKey": 5
          },
          {
            "name": "6.分割回文串.ts",
            "type": "file",
            "path": "src/7.回溯算法/6.分割回文串.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/palindrome-partitioning/description/\n */\n\nconst isBackString = (str: string) => {\n    return str === str.split(\"\").reverse().join(\"\")\n}\n\nfunction partition(s: string): string[][] {\n    const result: string[][] = []\n    const dfs = (startIdx: number, path: string[]) => {\n        if (startIdx >= s.length) {\n            result.push(path)\n            return\n        }\n        for (let idx = startIdx; idx < s.length; idx++) {\n            const str = s.slice(startIdx, idx + 1)\n            if (isBackString(str)) {\n                path.push(str)\n                dfs(idx + 1, path.concat([]))\n                path.pop()\n            } else {\n                continue\n            }\n        }\n    }\n    dfs(0, [])\n    return result\n}\n",
            "url": "https://leetcode.cn/problems/palindrome-partitioning/description/",
            "sortKey": 6
          },
          {
            "name": "7.复原ip地址.ts",
            "type": "file",
            "path": "src/7.回溯算法/7.复原ip地址.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/restore-ip-addresses/description/\n */\n\n// 是否是有效字符串\nconst isValidStr = (str: string) => {\n    if (str.length > 1) {\n        if (str.startsWith(\"0\")) {\n            return false\n        }\n        if (Number(str) >= 0 && Number(str) <= 255) {\n            return true\n        }\n        return false\n    }\n    return true\n}\nfunction restoreIpAddresses(s: string): string[] {\n    const result: string[] = []\n    const dfs = (path: string[], startIdx: number) => {\n        if (path.length === 4 && path.length === s.length) {\n            result.push(path.join(\".\"))\n            return\n        }\n        for (let i = startIdx; i < s.length; i++) {\n            const str = s.slice(startIdx, i + 1)\n            if (isValidStr(str)) {\n                path.push(str)\n                dfs(path.concat([]), i + 1)\n                path.pop()\n            } else {\n                continue\n            }\n        }\n    }\n    dfs([], 0)\n    return result\n}\n",
            "url": "https://leetcode.cn/problems/restore-ip-addresses/description/",
            "sortKey": 7
          },
          {
            "name": "8.子集.ts",
            "type": "file",
            "path": "src/7.回溯算法/8.子集.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/subsets/description/\n */\nfunction subsets(nums: number[]): number[][] {\n    const result: number[][] = []\n    const dfs = (path: number[], startIdx: number) => {\n        result.push(path)\n        if (startIdx >= nums.length) {\n            return\n        }\n        for (let i = startIdx; i < nums.length; i++) {\n            path.push(nums[i])\n            dfs(path.concat([]), i + 1)\n            path.pop()\n        }\n    }\n    dfs([], 0)\n    return result\n}\n",
            "url": "https://leetcode.cn/problems/subsets/description/",
            "sortKey": 8
          },
          {
            "name": "9.子集二.ts",
            "type": "file",
            "path": "src/7.回溯算法/9.子集二.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/subsets-ii/description/\n */\n\n// [1,2,2,3]\nfunction subsetsWithDup(nums: number[]): number[][] {\n    const result: number[][] = []\n    const used: boolean[] = new Array(nums.length).fill(false)\n    nums.sort((a, b) => a - b)\n    const dfs = (path: number[], startIdx: number) => {\n        result.push(path)\n        if (startIdx >= nums.length) {\n            return\n        }\n        for (let i = startIdx; i < nums.length; i++) {\n            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {\n                continue\n            }\n            used[i] = true\n            path.push(nums[i])\n            dfs(path.concat(), i + 1)\n            used[i] = false\n            path.pop()\n        }\n    }\n    dfs([], 0)\n    return result\n}\n",
            "url": "https://leetcode.cn/problems/subsets-ii/description/",
            "sortKey": 9
          },
          {
            "name": "10.非递减子序列.ts",
            "type": "file",
            "path": "src/7.回溯算法/10.非递减子序列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/non-decreasing-subsequences/description/\n */\n\n// TODO:1.边界条件 2.去重逻辑 (不能排序之后用used数组进行去重，会打乱原数组的顺序。)3.用set来去重，在树层的地方判断\n// 想要用used[i]去重，数组就必须要是有序的\n\nfunction findSubsequences(nums: number[]): number[][] {\n    const result: Array<Array<number>> = []\n    const dfs = (path: number[], startIdx: number) => {\n        if (path.length >= 2) {\n            result.push(path)\n        }\n        if (startIdx >= nums.length) {\n            return\n        }\n        const set: Set<number> = new Set()\n        for (let i = startIdx; i < nums.length; i++) {\n            if (nums[i] < path[path.length - 1]) {\n                continue\n            }\n            if (set.has(nums[i])) {\n                continue\n            }\n            set.add(nums[i])\n            path.push(nums[i])\n            dfs(path.concat([]), i + 1)\n            path.pop()\n        }\n    }\n    dfs([], 0)\n    return result\n}\n\nfunction findSubsequences1(nums: number[]): number[][] {\n    const res: number[][] = []\n    const dfs = (startIdx: number, path: number[]) => {\n        if (path.length >= 2) {\n            res.push(path)\n        }\n\n        if (startIdx >= nums.length) {\n            return\n        }\n        const set = new Set()\n\n        for (let i = startIdx; i < nums.length; i++) {\n            if (nums[i] < path[path.length - 1]) {\n                continue\n            }\n            if (set.has(nums[i])) {\n                continue\n            }\n            path.push(nums[i])\n            set.add(nums[i])\n            dfs(i + 1, [...path])\n            path.pop()\n        }\n    }\n    dfs(0, [])\n    return res\n}\n\nconsole.log(findSubsequences1([1, 1, 1, 1, 1, 1]))\n",
            "url": "https://leetcode.cn/problems/non-decreasing-subsequences/description/",
            "sortKey": 10
          },
          {
            "name": "11.全排列.ts",
            "type": "file",
            "path": "src/7.回溯算法/11.全排列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/permutations/description/\n */\n// TODO：组合问题是通过startIndex来取下标的，排列问题是通过used数组来取的\nfunction permute(nums: number[]): number[][] {\n    const result: number[][] = []\n    const dfs = (path: number[], used: boolean[]) => {\n        if (path.length === nums.length) {\n            result.push(path)\n            return\n        }\n        for (let i = 0; i < nums.length; i++) {\n            if (used[i] === true) {\n                continue\n            }\n            path.push(nums[i])\n            used[i] = true\n            dfs(path.concat([]), used)\n            path.pop()\n            used[i] = false\n        }\n    }\n    dfs([], new Array(nums.length).fill(false))\n    return result\n}\n",
            "url": "https://leetcode.cn/problems/permutations/description/",
            "sortKey": 11
          },
          {
            "name": "12.全排列二.ts",
            "type": "file",
            "path": "src/7.回溯算法/12.全排列二.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/permutations-ii/description/\n */\n// 跟11比起来就是数层去重\nfunction permuteUnique(nums: number[]): number[][] {\n    const result: number[][] = []\n    nums.sort((a, b) => a - b)\n    const dfs = (path: number[], used: boolean[]) => {\n        if (path.length === nums.length) {\n            result.push(path)\n            return\n        }\n\n        for (let i = 0; i < nums.length; i++) {\n            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {\n                continue\n            }\n            if (used[i] === true) {\n                continue\n            }\n            path.push(nums[i])\n            used[i] = true\n            dfs(path.concat([]), used)\n            path.pop()\n            used[i] = false\n        }\n    }\n    dfs([], new Array(nums.length).fill(false))\n    return result\n}\n",
            "url": "https://leetcode.cn/problems/permutations-ii/description/",
            "sortKey": 12
          },
          {
            "name": "13.N皇后.ts",
            "type": "file",
            "path": "src/7.回溯算法/13.N皇后.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/n-queens/description/\n */\n\nfunction solveNQueens(n: number): string[][] {\n    const final: string[][] = []\n    const result: string[][] = new Array(n).fill(0).map((_v) => new Array(n).fill(\".\"))\n\n    const isValid = (row: number, col: number) => {\n        // 检查列上是否有冲突\n        for (let i = row; i >= 0; i--) {\n            if (result[i][col] === \"Q\") {\n                return false\n            }\n        }\n        // 检查右上角上是否有冲突\n        for (let i = row, j = col; i >= 0 && j >= 0; j--, i--) {\n            if (result[i][j] === \"Q\") {\n                return false\n            }\n        }\n        // 检查左上角上是否有冲突\n        for (let i = row, j = col; i >= 0 && j < n; i--, j++) {\n            if (result[i][j] === \"Q\") {\n                return false\n            }\n        }\n        return true\n    }\n\n    const dfs = (row: number) => {\n        if (row === n) {\n            final.push(result.concat([]).map((_row) => _row.join(\"\")))\n            return\n        }\n        for (let col = 0; col < n; col++) {\n            if (isValid(row, col)) {\n                result[row][col] = \"Q\"\n                dfs(row + 1)\n                result[row][col] = \".\"\n            }\n        }\n    }\n    dfs(0)\n    return final\n}\n\nconsole.log(solveNQueens(4))\n",
            "url": "https://leetcode.cn/problems/n-queens/description/",
            "sortKey": 13
          },
          {
            "name": "14.删除无效的括号.ts",
            "type": "file",
            "path": "src/7.回溯算法/14.删除无效的括号.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/remove-invalid-parentheses/solutions/1068652/gong-shui-san-xie-jiang-gua-hao-de-shi-f-asu8/\n */\n",
            "url": "https://leetcode.cn/problems/remove-invalid-parentheses/solutions/1068652/gong-shui-san-xie-jiang-gua-hao-de-shi-f-asu8/",
            "sortKey": 14
          }
        ],
        "sortKey": 7
      },
      {
        "name": "8.动态规划",
        "type": "directory",
        "path": "src/8.动态规划",
        "children": [
          {
            "name": "1.斐波那契数.ts",
            "type": "file",
            "path": "src/8.动态规划/1.斐波那契数.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/fibonacci-number/description/\n */\nfunction fib(n: number): number {\n    let dp = new Array(n + 1).fill(0)\n    dp[0] = 0\n    dp[1] = 1\n    for (let i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n}\n",
            "url": "https://leetcode.cn/problems/fibonacci-number/description/",
            "sortKey": 1
          },
          {
            "name": "2.爬楼梯.ts",
            "type": "file",
            "path": "src/8.动态规划/2.爬楼梯.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/climbing-stairs/description/\n */\nfunction climbStairs(n: number): number {\n    const dp = new Array(n + 1).fill(false)\n    dp[0] = 0\n    dp[1] = 1\n    dp[2] = 2\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n}\n",
            "url": "https://leetcode.cn/problems/climbing-stairs/description/",
            "sortKey": 2
          },
          {
            "name": "3.使用最小花费爬楼梯.ts",
            "type": "file",
            "path": "src/8.动态规划/3.使用最小花费爬楼梯.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/min-cost-climbing-stairs/description/\n */\n\n// notice：注意审题，可以从下标为0，下标为1开始爬\nfunction minCostClimbingStairs(cost: number[]): number {\n    const dp = new Array(cost.length + 1).fill(0) // notice：dp表示当前爬下标为n的楼梯所需要的最小花费, 到楼顶表示当前下标要溢出数组\n    dp[0] = 0\n    dp[1] = 0\n\n    for (let i = 2; i <= cost.length; i++) {\n        dp[i] = Math.min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1])\n    }\n    console.log(dp)\n\n    return dp[dp.length - 1]\n}\n",
            "url": "https://leetcode.cn/problems/min-cost-climbing-stairs/description/",
            "sortKey": 3
          },
          {
            "name": "4.不同路径.ts",
            "type": "file",
            "path": "src/8.动态规划/4.不同路径.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/unique-paths/description/\n */\n\nfunction uniquePaths(m: number, n: number): number {\n    const dp = new Array(m).fill(0).map((_num) => new Array(n).fill(0)) // m * n 的二维数组\n\n    // TODO:注意这个是路径，不是走了多少步\n    // const initDp = () => {\n    //     for (let row = 0; row < m; row++) {\n    //         dp[row][0] = row\n    //     }\n    //     for (let col = 0; col < n; col++) {\n    //         dp[0][col] = col\n    //     }\n    // }\n\n    const initDp = () => {\n        for (let row = 0; row < m; row++) {\n            dp[row][0] = 1\n        }\n        for (let col = 0; col < n; col++) {\n            dp[0][col] = 1\n        }\n    }\n    dp[0][0] = 0\n    initDp()\n\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        }\n    }\n\n    return dp[m - 1][n - 1]\n}\n\nconsole.log(uniquePaths(3, 2))\n",
            "url": "https://leetcode.cn/problems/unique-paths/description/",
            "sortKey": 4
          },
          {
            "name": "5.不同路径2.ts",
            "type": "file",
            "path": "src/8.动态规划/5.不同路径2.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/unique-paths-ii/description/\n */\n\n// TODO:注意初始化的操作\nfunction uniquePathsWithObstacles(obstacleGrid: number[][]): number {\n  const dp = new Array(obstacleGrid.length)\n    .fill(0)\n    .map((_num) => new Array(obstacleGrid[0].length).fill(0)); // m * n 的二维数组\n  if (obstacleGrid[0][0] === 1) return 0;\n  const initDp = () => {\n    for (let row = 0; row < obstacleGrid.length; row++) {\n      if (obstacleGrid[row][0] === 1) {\n        dp[row][0] = 0;\n        break;\n      } else {\n        dp[row][0] = 1;\n      }\n    }\n    for (let col = 0; col < obstacleGrid[0].length; col++) {\n      if (obstacleGrid[0][col] === 1) {\n        dp[0][col] = 0;\n        break;\n      } else {\n        dp[0][col] = 1;\n      }\n    }\n  };\n  dp[0][0] = 0;\n  initDp();\n\n  for (let i = 1; i < obstacleGrid.length; i++) {\n    for (let j = 1; j < obstacleGrid[0].length; j++) {\n      if (obstacleGrid[i][j] === 1) {\n        dp[i][j] = 0;\n      } else {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n  }\n  console.log(dp);\n\n  return dp[obstacleGrid.length - 1][obstacleGrid[0].length - 1];\n}\n\n// ! 暴力解法\n/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nvar uniquePathsWithObstaclesViolent = function (obstacleGrid) {\n  // 如果起点或终点是障碍，直接返回0\n  if (\n    obstacleGrid[0][0] === 1 ||\n    obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1] === 1\n  ) {\n    return 0;\n  }\n\n  const m = obstacleGrid.length;\n  const n = obstacleGrid[0].length;\n  let pathCount = 0;\n\n  // 方向数组：向下和向右\n  const directions = [\n    [1, 0],\n    [0, 1],\n  ]; // [row, col]\n\n  function backtrack(row, col) {\n    // 到达终点，路径数加1\n    if (row === m - 1 && col === n - 1) {\n      pathCount++;\n      return;\n    }\n\n    // 尝试每个方向\n    for (let [dr, dc] of directions) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n\n      // 检查边界和障碍\n      if (newRow < m && newCol < n && obstacleGrid[newRow][newCol] !== 1) {\n        backtrack(newRow, newCol);\n      }\n    }\n  }\n\n  // 从起点开始\n  backtrack(0, 0);\n  return pathCount;\n};\n\n// 测试用例\nconsole.log(\n  uniquePathsWithObstacles([\n    [0, 0, 0],\n    [0, 1, 0],\n    [0, 0, 0],\n  ])\n); // 输出 2\n\nconsole.log(\n  uniquePathsWithObstacles([\n    [0, 1],\n    [0, 0],\n  ])\n); // 输出 1\n",
            "url": "https://leetcode.cn/problems/unique-paths-ii/description/",
            "sortKey": 5
          },
          {
            "name": "6.整数拆分.ts",
            "type": "file",
            "path": "src/8.动态规划/6.整数拆分.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/integer-break/description/\n */\n\n// dp[n]表示n拆分至少两个数的最大乘积\nfunction integerBreak(n: number): number {\n    const dp = new Array(n + 1).fill(0)\n    dp[0] = 0\n    dp[1] = 0\n    dp[2] = 1\n    for (let i = 3; i <= n; i++) {\n        // 拆分成0其实没有意义，所以这里拆分成1开始\n        for (let j = 1; j < i; j++) {\n            dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j])\n        }\n    }\n    return dp[n]\n}\n",
            "url": "https://leetcode.cn/problems/integer-break/description/",
            "sortKey": 6
          },
          {
            "name": "7.不同的二叉搜索树.ts",
            "type": "file",
            "path": "src/8.动态规划/7.不同的二叉搜索树.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/unique-binary-search-trees/description/\n * @resolve https://leetcode.cn/problems/unique-binary-search-trees/solutions/6693/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/\n */\n// G[n]代表n个节点的二叉搜索树的个数\n// f[i]代表以i为根节点的二叉搜索树的个数\n\n// G[n] = f(1)+f(2)+....f(n)\n// f(i) = G(i-1)*G(n-i) // 左子树的个数有i-1个，右子树的个数有n-i个\n// G(n) = G(0)*G(n-1)+G(1)*G(1)+.....G(n-1)*G(0)\n\nfunction numTrees(n: number): number {\n    const dp = new Array(n + 1).fill(0) // dp[n]表示n个节点的二叉树的个数\n    dp[1] = 1\n    dp[0] = 1 // 其实没有任何意义\n    for (let i = 2; i <= n; i++) {\n        for (let j = 1; j <= i; j++) {\n            dp[i] += dp[j - 1] * dp[i - j]\n        }\n    }\n\n    return dp[n]\n}\n",
            "url": "https://leetcode.cn/problems/unique-binary-search-trees/description/",
            "sortKey": 7
          },
          {
            "name": "9.分割等和子集.ts",
            "type": "file",
            "path": "src/8.动态规划/9.分割等和子集.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/partition-equal-subset-sum/description/\n */\n\n// dp[i][j]表示从[0,i]个物品中选取，是否有一种方案恰好能够装满容量j。\n// 提示：\n// 1 <= nums.length <= 200\n// 1 <= nums[i] <= 100\n\n// function canPartition(nums: number[]): boolean {\n//     const target = nums.reduce((acc, cur) => acc + cur, 0) / 2\n//     if (!Number.isInteger(target)) return false\n\n//     const dp: boolean[][] = new Array(nums.length).fill(false).map((_arr) => new Array(target + 1).fill(false))\n\n//     dp[0][nums[0]] = true\n\n//     for (let row = 0; row < nums.length; row++) {\n//         dp[row][0] = true\n//     }\n\n//     for (let row = 1; row < nums.length; row++) {\n//         for (let col = 1; col < target + 1; col++) {\n//             if (col - nums[row] >= 0) {\n//                 dp[row][col] = dp[row - 1][col] || dp[row - 1][col - nums[row]]\n//             } else {\n//                 dp[row][col] = dp[row - 1][col]\n//             }\n//         }\n//     }\n\n//     return dp[nums.length - 1][target]\n// }\n\n//TODO:优化 dp[j]表示是否有一种方案能够装满dp[j]\nfunction canPartition(nums: number[]): boolean {\n  const sum = nums.reduce((acc, cur) => acc + cur);\n  const capaticy = sum / 2;\n  if (!Number.isInteger(capaticy)) {\n    return false;\n  }\n  const dp: boolean[] = new Array(capaticy + 1).fill(false); // 数组下标和容量的差距\n\n  dp[0] = true;\n  for (let row = 0; row < nums.length; row++) {\n    for (let col = capaticy; col >= nums[row]; col--) {\n      dp[col] = dp[col] || dp[col - nums[row]];\n    }\n  }\n  return dp[capaticy];\n}\n",
            "url": "https://leetcode.cn/problems/partition-equal-subset-sum/description/",
            "sortKey": 9
          },
          {
            "name": "10.最后一块石头的重量 II.ts",
            "type": "file",
            "path": "src/8.动态规划/10.最后一块石头的重量 II.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/last-stone-weight-ii/description/\n */\n\n// TODO:如何将问题抽象成01背包问题？\n\n// 要使最后一块石头的重量尽可能地小，neg 需要在不超过 ⌊sum/2⌋ 的前提下尽可能地大。因此本问题可以看作是背包容量为 ⌊sum/2⌋，物品重量和价值均为 stones\n\n// function lastStoneWeightII(stones: number[]): number {\n//     const sum = stones.reduce((acc, cur) => acc + cur, 0)\n//     const target = Math.floor(sum / 2)\n//     const dp = new Array(stones.length).fill(0).map((_arr) => new Array(target + 1).fill(0))\n//     for (let i = 0; i < stones.length; i++) {\n//         dp[i][0] = 0\n//     }\n//     for (let j = 0; j <= target; j++) {\n//         if (j >= stones[0]) {\n//             dp[0][j] = stones[0]\n//         } else {\n//             dp[0][j] = 0\n//         }\n//     }\n\n//     for (let row = 1; row < stones.length; row++) {\n//         for (let col = 1; col <= target; col++) {\n//             if (col - stones[row] >= 0) {\n//                 dp[row][col] = Math.max(dp[row - 1][col], dp[row - 1][col - stones[row]] + stones[row])\n//             } else {\n//                 dp[row][col] = dp[row - 1][col]\n//             }\n//         }\n//     }\n//     return Math.abs(sum - dp[stones.length - 1][target] - dp[stones.length - 1][target])\n// }\n\n// notice：抽离成一维数组\nfunction lastStoneWeightII(stones: number[]): number {\n  const sum = stones.reduce((acc, cur) => acc + cur, 0);\n  const target = Math.floor(sum / 2);\n\n  const dp: number[] = new Array(target + 1).fill(0);\n  dp[0] = 0;\n\n  for (let row = 0; row < stones.length; row++) {\n    console.dir(dp);\n\n    for (let col = target; col >= stones[row]; col--) {\n      dp[col] = Math.max(dp[col - stones[row]] + stones[row], dp[col]);\n    }\n  }\n\n  console.dir(dp);\n  return Math.abs(sum - dp[target] - dp[target]);\n}\n\nlastStoneWeightII([2, 7, 4, 1, 8, 1]);\n",
            "url": "https://leetcode.cn/problems/last-stone-weight-ii/description/",
            "sortKey": 10
          },
          {
            "name": "11.目标和.ts",
            "type": "file",
            "path": "src/8.动态规划/11.目标和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/target-sum/description/\n */\n// left + right = sum\n// left - right = target\n// left = (sum + target) / 2\n\n// TODO:初始化很难\n// notice:01背包应用之“有多少种不同的填满背包最大容量的方法“\n// function findTargetSumWays(nums: number[], target: number): number {\n//     let sum = nums.reduce((acc, cur) => acc + cur, 0)\n//     if (Math.abs(target) > sum) return 0\n//     let beibao = (sum + target) / 2\n//     if (!Number.isInteger(beibao)) return 0\n//     if (target > sum) return 0\n//     const dp = new Array(nums.length).fill(0).map((_arr) => new Array(beibao + 1 || 1).fill(0))\n\n//     dp[0][nums[0]] = 1 // 注意这个顺序\n\n//     // 背包容量为0，只要出现了0，就可以代表2^n\n\n//     let numZeros = 0\n//     for (let i = 0; i < nums.length; i++) {\n//         if (nums[i] == 0) {\n//             numZeros++\n//         }\n//         dp[i][0] = Math.pow(2, numZeros)\n//     }\n\n//     for (let i = 1; i < nums.length; i++) {\n//         for (let j = 1; j < beibao + 1; j++) {\n//             if (j - nums[i] < 0) {\n//                 dp[i][j] = dp[i - 1][j]\n//             } else {\n//                 dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]\n//             }\n//         }\n//     }\n//     console.table(dp)\n\n//     // console.log(dp)\n//     return dp[nums.length - 1][beibao]\n// }\n\n// TODO:优化 一维数组\n// left + right = target  left -right = sum  left = (sum + target) / 2\n// dp[target]  装满背包容量target有多少种方法\nfunction findTargetSumWays(nums: number[], target: number): number {\n    const sum = nums.reduce((acc, cur) => acc + cur, 0)\n    const capacity = (sum + target) / 2\n    if (!Number.isInteger(capacity)) return 0\n    if (Math.abs(target) > sum) return 0\n    const dp = new Array(capacity + 1).fill(0)\n    dp[0] = 1 // 装满背包容量为0，可以什么都不装也为一种方案\n    for (let row = 0; row < nums.length; row++) {\n        console.log(dp)\n        for (let col = capacity; col >= nums[row]; col--) {\n            dp[col] = dp[col - nums[row]] + dp[col]\n        }\n    }\n\n    return dp[capacity]\n}\n\nfindTargetSumWays([1, 2, 1, 2], 4)\n",
            "url": "https://leetcode.cn/problems/target-sum/description/",
            "sortKey": 11
          },
          {
            "name": "12.一和零.ts",
            "type": "file",
            "path": "src/8.动态规划/12.一和零.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/ones-and-zeroes/description/\n */\n\n// dp表示不超过容量的情况下，有多少个子集\n// !本质还是01背包，维度从1维变成2维了，0 和 1\nfunction findMaxForm(strs: string[], m: number, n: number): number {\n  const dp = new Array(m + 1).fill(0).map((_v) => new Array(n + 1).fill(0));\n\n  dp[0][0] = 0;\n\n  const getMandN = (str: string) => {\n    let m = 0,\n      n = 0;\n    for (let i = 0; i < str.length; i++) {\n      if (str[i] === \"1\") {\n        n++;\n      } else {\n        m++;\n      }\n    }\n    return {\n      m,\n      n,\n    };\n  };\n\n  for (let i = 0; i < strs.length; i++) {\n    const { m: strm, n: strn } = getMandN(strs[i]);\n    for (let j = m; j >= strm; j--) {\n      for (let k = n; k >= strn; k--) {\n        dp[j][k] = Math.max(dp[j - strm][k - strn] + 1, dp[j][k]);\n      }\n    }\n  }\n\n  return dp[m][n];\n}\n\nfindMaxForm([\"10\", \"0001\", \"111001\", \"1\", \"0\"], 5, 3);\n",
            "url": "https://leetcode.cn/problems/ones-and-zeroes/description/",
            "sortKey": 12
          },
          {
            "name": "14.零钱兑换二.ts",
            "type": "file",
            "path": "src/8.动态规划/14.零钱兑换二.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/coin-change-ii/description/\n */\n\n// notice：背包容量为j的最大价值是否能为j，物品可以被选取多少次\n// TODO:遍历顺序的考量。dp概念的理解\n// []如果求组合数就是外层for循环遍历物品，内层for遍历背包。\n// []如果求排列数就是外层for遍历背包，内层for循环遍历物品。\nfunction change(amount: number, coins: number[]): number {\n  const dp = new Array(amount + 1).fill(0);\n  dp[0] = 1;\n  for (let i = 0; i < coins.length; i++) {\n    for (let j = coins[i]; j <= amount; j++) {\n      dp[j] += dp[j - coins[i]];\n    }\n  }\n  console.log(dp);\n\n  return dp[amount];\n}\n\nchange(5, [1, 2, 5]);\n",
            "url": "https://leetcode.cn/problems/coin-change-ii/description/",
            "sortKey": 14
          },
          {
            "name": "15.组合总和四.ts",
            "type": "file",
            "path": "src/8.动态规划/15.组合总和四.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/combination-sum-iv/description/\n */\n\n// dp[j]表示装满背包为j的元素组合的个数\n// notice:其实这个地方就是一个排列\n\nfunction combinationSum4(nums: number[], target: number): number {\n    const dp = new Array(target + 1).fill(0)\n    dp[0] = 1\n    for (let j = 0; j < target + 1; j++) {\n        for (let i = 0; i < nums.length; i++) {\n            if (j - nums[i] >= 0) {\n                dp[j] += dp[j - nums[i]]\n            }\n        }\n    }\n\n    return dp[target]\n}\n\nconsole.log(combinationSum4([1, 2, 3], 4))\n\n// TODO: 暴力算出所有的组合",
            "url": "https://leetcode.cn/problems/combination-sum-iv/description/",
            "sortKey": 15
          },
          {
            "name": "16.零钱兑换.ts",
            "type": "file",
            "path": "src/8.动态规划/16.零钱兑换.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/coin-change/description/\n */\n\n// dp[j]表示刚好装满容量为j的最少硬币个数\nfunction coinChange(coins: number[], amount: number): number {\n    const dp = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER) // notice：初始化的时候：保证能够不是最初的小值\n    dp[0] = 0\n    for (let i = 0; i < coins.length; i++) {\n        for (let j = coins[i]; j <= amount; j++) {\n            dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1)\n        }\n    }\n    console.log(dp)\n    return dp[amount] === Number.MAX_SAFE_INTEGER ? -1 : dp[amount]\n}\n",
            "url": "https://leetcode.cn/problems/coin-change/description/",
            "sortKey": 16
          },
          {
            "name": "17.完全平方数.ts",
            "type": "file",
            "path": "src/8.动态规划/17.完全平方数.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/perfect-squares/description/\n */\n\n// dp[n]表示容量为n的情况下，最少需要多少整数来组成n\nfunction numSquares(n: number): number {\n    const dp = new Array(n + 1).fill(Number.MAX_SAFE_INTEGER)\n    dp[0] = 0\n    for (let i = 1; i <= Math.floor(Math.sqrt(n)); i++) {\n        for (let j = Math.pow(i, 2); j <= n; j++) {\n            dp[j] = Math.min(dp[j], dp[j - Math.pow(i, 2)] + 1)\n        }\n    }\n    return dp[n]\n}\n",
            "url": "https://leetcode.cn/problems/perfect-squares/description/",
            "sortKey": 17
          },
          {
            "name": "18.单词拆分.ts",
            "type": "file",
            "path": "src/8.动态规划/18.单词拆分.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/word-break/description/\n */\n\n// 排列还是组合，遍历顺序的考量 dp[j]表示长度为j的字符串是否能够被拼接\n// !notice：这一维度的赋值\nfunction wordBreak(s: string, wordDict: string[]): boolean {\n  const dp = new Array(s.length + 1).fill(false);\n  dp[0] = true;\n\n  for (let j = 1; j <= s.length; j++) {\n    // 这个for循环每次都会对dp进行覆盖操作\n    for (let i = 0; i < wordDict.length; i++) {\n      const word = wordDict[i];\n      if (j >= word.length) {\n        const word1 = s.slice(j - word.length, j);\n        if (word === word1 && dp[j - word.length]) {\n          dp[j] = true;\n          break; // 如果不加break，后面遍历上来，可能会把他给覆盖。\n        } else {\n          dp[j] = false;\n        }\n      } else {\n        dp[j] = false;\n      }\n    }\n  }\n\n  return dp[s.length];\n}\n\nwordBreak(\"applepenapple\", [\"apple\", \"pen\"]);\n\n// !notice：暴力回溯递归解法\nfunction wordBreak1(s, wordDict) {}\n\n// const wordBreak = (s, wordDict) => {\n//   let dp = Array(s.length + 1).fill(false);\n//   dp[0] = true;\n\n//   for (let i = 0; i <= s.length; i++) {\n//     for (let j = 0; j < wordDict.length; j++) {\n//       if (i >= wordDict[j].length) {\n//         if (\n//           s.slice(i - wordDict[j].length, i) === wordDict[j] &&\n//           dp[i - wordDict[j].length]\n//         ) {\n//           dp[i] = true;\n//         }\n//       }\n//     }\n//   }\n\n//   return dp[s.length];\n// };\n",
            "url": "https://leetcode.cn/problems/word-break/description/",
            "sortKey": 18
          },
          {
            "name": "19.打家劫舍.ts",
            "type": "file",
            "path": "src/8.动态规划/19.打家劫舍.ts",
            "content": "export {};\n/**\n * @url https://leetcode.cn/problems/house-robber/description/\n */\n\n// dp[i]表示偷窃第i+1间房屋所能获得的最大金额\n// dp[2] = dp[0]+cur, dp[1]\n// dp[3] = dp[1]+cur,dp[2]\n// dp[n] = dp[n-2]+cur dp[n-1]\n// !notice:因为题目中都是正数，所以这里不需要考虑前面()，dp[i-1]一定是没有选择i的最大值，实际上也是运用到了一点贪心的策略\nfunction rob(nums: number[]): number {\n  const dp = new Array(nums.length).fill(0);\n  dp[0] = nums[0];\n  if (nums.length === 1) {\n    return dp[0];\n  }\n  dp[1] = Math.max(nums[0], nums[1]);\n  for (let i = 2; i < nums.length; i++) {\n    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1], dp[i]);\n  }\n\n  return dp[nums.length - 1];\n}\n\n/**\n * @url https://leetcode.cn/problems/house-robber/description/\n */\n\n// dp[i]表示偷窃第i+1间房屋所能获得的最大金额，\n// dp[2] = dp[0]+cur, dp[1]\n// dp[3] = dp[1]+cur,dp[2]\n// dp[n] = dp[n-2]+cur dp[n-1]\nfunction rob1(nums: number[]): number {\n  const dp = new Array(nums.length).fill(0);\n  dp[0] = nums[0];\n  if (nums.length === 1) {\n    return dp[0];\n  }\n  dp[1] = Math.max(nums[0], nums[1]);\n  for (let i = 2; i < nums.length; i++) {\n    for (let j = 0; j < i - 1; j++) {\n      // dp[j] + nums[i] 表示需要当天的\n      // dp[i - 1] 不要当天\n      // dp[i] 对比\n      dp[i] = Math.max(dp[j] + nums[i], dp[i], dp[i - 1]);\n    }\n  }\n\n  return dp[nums.length - 1];\n}\n",
            "url": "https://leetcode.cn/problems/house-robber/description/",
            "sortKey": 19
          },
          {
            "name": "20.打家劫舍二.ts",
            "type": "file",
            "path": "src/8.动态规划/20.打家劫舍二.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/house-robber-ii/description/\n */\n\n// 偷了1就不能够偷最后一个，偷了最后一个就不能偷第一个\n// TODO:dp[i]表示到达第[i+1]房屋所能偷到的最大额度\nfunction rob(nums: number[]): number {\n    const dp1 = new Array(nums.length - 1).fill(0)\n    const dp2 = new Array(nums.length - 1).fill(0)\n    if (nums.length === 1) return nums[0]\n    dp1[0] = nums[0]\n    dp1[1] = Math.max(nums[0], nums[1])\n    dp2[0] = nums[1]\n    dp2[1] = Math.max(nums[1], nums[2])\n\n    const nums1 = nums.concat([])\n    const nums2 = nums.concat([])\n    nums1.pop()\n    nums2.shift()\n    for (let i = 2; i < nums1.length; i++) {\n        dp1[i] = Math.max(dp1[i - 2] + nums1[i], dp1[i - 1])\n    }\n    for (let i = 2; i < nums2.length; i++) {\n        dp2[i] = Math.max(dp2[i - 2] + nums2[i], dp2[i - 1])\n    }\n\n    console.log(dp1, dp2)\n\n    return Math.max(dp1[nums.length - 2], dp2[nums.length - 2])\n}\nconsole.log(rob([1, 3, 2]))\n",
            "url": "https://leetcode.cn/problems/house-robber-ii/description/",
            "sortKey": 20
          },
          {
            "name": "21.打家劫舍三.ts",
            "type": "file",
            "path": "src/8.动态规划/21.打家劫舍三.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/house-robber-iii/description/\n */\nexport {} // 表明是一个模块，防止ts报错\n\n// TODO:树形dp，与数组的区别是定义每个节点的一个状态\nclass TreeNode {\n    val: number\n    left: TreeNode | null\n    right: TreeNode | null\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val\n        this.left = left === undefined ? null : left\n        this.right = right === undefined ? null : right\n    }\n}\n\n// dp[0]表示当前节点未偷 dp[1]表示当前节点已经被偷\n// function rob(root: TreeNode | null): number {\n//     const traverse = (root: TreeNode | null): Array<number> => {\n//         const dp: number[] = new Array(2).fill(0)\n\n//         if (!root) return dp.concat([])\n//         if (!root.left && !root.right) {\n//             dp[1] = root.val\n//             return dp.concat()\n//         }\n//         // 节点被偷\n//         dp[1] = root.val + traverse(root.left)[0] + traverse(root.right)[0]\n\n//         // 节点未被偷，但也不一定是会去子节点的最大值呀！！！！\n//         dp[0] = traverse(root.left)[1] + traverse(root.right)[1]\n\n//         return dp.concat([])\n//     }\n\n//     return Math.max(...traverse(root))\n// }\n\nfunction rob(root: TreeNode | null): number {\n    const traverse = (root: TreeNode | null): Array<number> => {\n        const dp: number[] = new Array(2).fill(0)\n\n        if (!root) return dp.concat([])\n        if (!root.left && !root.right) {\n            dp[1] = root.val\n            return dp.concat()\n        }\n\n        // 后序遍历\n        const left = traverse(root.left)\n        const right = traverse(root.right)\n\n        // 节点被偷\n        dp[1] = root.val + left[0] + right[0]\n\n        // 节点未被偷，但也不一定是会去子节点的最大值呀！！！！\n        dp[0] = Math.max(...left) + Math.max(...right)\n\n        return dp.concat([])\n    }\n\n    return Math.max(...traverse(root))\n}\n",
            "url": "https://leetcode.cn/problems/house-robber-iii/description/",
            "sortKey": 21
          },
          {
            "name": "22.买卖股票的最佳时机.ts",
            "type": "file",
            "path": "src/8.动态规划/22.买卖股票的最佳时机.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/\n */\nexport {};\n// [7,1,5,3,6,4]  5\n// 暴力解法--超时\n// function maxProfit(prices: number[]): number {\n//     let max = Number.MIN_SAFE_INTEGER\n//     for (let i = 0; i < prices.length; i++) {\n//         for (let j = i + 1; j < prices.length; j++) {\n//             max = Math.max(max, prices[j] - prices[i])\n//         }\n//     }\n//     return max < 0 ? 0 : max\n// }\n\n// dp[i][0] 表示 第i天持有股票所拥有的最大金额\n//     保持上一次的持有股票状态\n//     刚买入\n// dp[i][1] 表示 第i天不持有股票所拥有的最大金额\n//     上一次没有持有股票的状态\n//     按照今天的股价卖出\n\n// !notice：表示一天时间\nfunction maxProfit(prices: number[]): number {\n  const dp = new Array(prices.length)\n    .fill(0)\n    .map((_item) => new Array(2).fill(0));\n  dp[0][0] = -prices[0];\n  dp[0][1] = 0;\n  for (let i = 1; i < prices.length; i++) {\n    dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); // !notice:这里-price[i]不依赖于之前的状态。因为题目限定只需要执行一次，具体可参照 23.买股票的最佳时机二.ts\n    dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);\n  }\n  return dp[prices.length - 1][1];\n}\n\n// TODO:一维数组优化\n\n// note:思路参考背包问题\nfunction maxProfitOne(prices: number[]): number {\n  const dp = new Array(2).fill(Number.MIN_SAFE_INTEGER);\n  for (let i = 0; i < prices.length; i++) {\n    // dp[i][0] = Math.max(dp[i - 1][0], -prices[i])\n    // dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0])\n    // TODO:这里本身会被覆盖，因此需要用两层递归\n    dp[0] = Math.max(dp[0], -prices[i]);\n    dp[1] = Math.max(dp[1], dp[0] + prices[i]);\n  }\n  return dp[1];\n}\n",
            "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/",
            "sortKey": 22
          },
          {
            "name": "23.买股票的最佳时机二.ts",
            "type": "file",
            "path": "src/8.动态规划/23.买股票的最佳时机二.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/\n */\n// dp[i][0]表示第i天所拥有的最大利润\n// dp[i][0]表示第i天持有股票所拥有的最大利润\n// dp[i][1]表示第i天不持有股票所拥有的最大利润\nfunction maxProfit(prices: number[]): number {\n    const dp: number[] = new Array(2).fill(0)\n    dp[0] = -prices[0]\n    dp[1] = 0\n    for (let i = 1; i < prices.length; i++) {\n        // 这里会被覆盖，可以用两层数组来保存\n        dp[0] = Math.max(dp[0], dp[1] - prices[i])\n        dp[1] = Math.max(dp[1], dp[0] + prices[i])\n    }\n    return dp[1]\n}\n",
            "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/",
            "sortKey": 23
          },
          {
            "name": "24.买股票的最佳时机三.ts",
            "type": "file",
            "path": "src/8.动态规划/24.买股票的最佳时机三.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/\n */\nexport {};\n\n// TODO:最多完成几笔交易，状态怎么办？想想前两次股票递推的第二个参数的意思  和前面两题是一样的\n\n// dp[i][0]表示在第i天中，第一次买入股票的最大利润 dp[i][0] = -price[i]\n// dp[i][1]表示在第i天中，第一次卖出股票的最大利润 dp[i][1] =  dp[i-1]+price[i]\n// dp[i][2]表示在第i天中，第二次买入股票的最大利润 dp[i][2] = dp[i-1][1]-price[i]\n// dp[i][3]表示在第i天中，第二次卖出股票的最大利润 dp[i][3] = dp[i-1][2]+price[i]\nfunction maxProfit(prices: number[]): number {\n  const dp = new Array(prices.length)\n    .fill(0)\n    .map((_arr) => new Array(4).fill(0));\n  dp[0][0] = -prices[0];\n  dp[0][1] = 0;\n  dp[0][2] = -prices[0];\n  dp[0][3] = 0;\n  for (let i = 1; i < prices.length; i++) {\n    dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);\n    dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i]);\n    dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i]);\n  }\n  return dp[prices.length - 1][3];\n}\n\n// TODO:空间优化\nfunction maxProfit1(prices: number[]): number {\n  const dp = new Array(4).fill(0);\n  dp[0] = -prices[0];\n  dp[1] = 0;\n  dp[2] = -prices[0];\n  dp[3] = 0;\n  for (let i = 1; i < prices.length; i++) {\n    dp[i][0] = Math.max(dp[0], -prices[i]);\n    dp[i][1] = Math.max(dp[1], dp[0] + prices[i]);\n    dp[i][2] = Math.max(dp[2], dp[1] - prices[i]);\n    dp[i][3] = Math.max(dp[3], dp[2] + prices[i]);\n  }\n  return dp[3];\n}\n",
            "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/",
            "sortKey": 24
          },
          {
            "name": "25.买股票的最佳时机四.ts",
            "type": "file",
            "path": "src/8.动态规划/25.买股票的最佳时机四.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/\n */\n\nexport {}\n\n// 两笔交易\n// dp[i][0]表示在第i天中，第一次买入股票的最大利润 dp[i][0] = dp[i-1][0],-price[i]\n// dp[i][1]表示在第i天中，第一次卖出股票的最大利润 dp[i][1] = dp[i-1][1],dp[i-1][0]+price[i]\n// dp[i][2]表示在第i天中，第二次买入股票的最大利润 dp[i][2] = dp[i-1][2],dp[i-1][1]-price[i]\n// dp[i][3]表示在第i天中，第二次卖出股票的最大利润 dp[i][3] = dp[i-1][3],dp[i-1][2]+price[i]\nfunction maxProfit(k: number, prices: number[]): number {\n    const dp: number[][] = new Array(prices.length).fill(0).map((_item) => new Array(2 * k).fill(0))\n    for (let i = 0; i < 2 * k; i++) {\n        if (i % 2 === 0) {\n            dp[0][i] = -prices[0]\n        } else {\n            dp[0][i] = 0\n        }\n    }\n    for (let i = 1; i < prices.length; i++) {\n        for (let j = 0; j < 2 * k; j++) {\n            if (j === 0) {\n                dp[i][j] = Math.max(dp[i - 1][0], -prices[i])\n            } else {\n                if (j % 2 === 0) {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i])\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i])\n                }\n            }\n        }\n    }\n    return dp[prices.length - 1][2 * k - 1]\n}\n",
            "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/",
            "sortKey": 25
          },
          {
            "name": "26.买卖股票的最佳时机含冷冻期.ts",
            "type": "file",
            "path": "src/8.动态规划/26.买卖股票的最佳时机含冷冻期.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/\n */\n\n// dp[i][0]表示第i天手上有股票时候的能够获取的最大利润\n// dp[i][1]表示第i天手上没有股票时候的能够获取的最大利润\n// dp[i][2]表示第i天处于冷冻期的时候的最大利润\n\n// 状态还是没考虑全\n// function maxProfit(prices: number[]): number {\n//     const dp = new Array(prices.length).fill(0).map((_item) => new Array(3).fill(0))\n//     dp[0][0] = -prices[0]\n//     dp[0][1] = 0\n//     dp[0][0] = 0\n\n//     for (let i = 1; i < prices.length; i++) {\n//         dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i], dp[i - 1][2] - prices[i])\n//         dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i], dp[i - 1][2])\n//         dp[i][2] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][2])\n//     }\n//     return Math.max(...dp[prices.length - 1])\n// }\n\n// TODO:再来做一遍\n// notice:关键点：不持有股票的状态拆分出来\n// 初始化如果非法的话，可以从递推公式来看具体初始化多少\n// dp[i][0]表示持有股票的最大利润 dp[i-1][0],dp[i-1][2]-price[i],dp[i-1][3]-price[i]\n// Note:备注一下 dp[i-1][3]-price[i]表示前一天是冷冻期，然后今天买入股票\n// dp[i][1]表示今天卖出股票，下一天是冷冻期 dp[i-1][0]+price[i]\n// dp[i][2]表示冷冻期之后保持卖出的状态 dp[i-1][2],dp[i-1][3]\n// dp[i][3]表示冷冻期的状态 dp[i-1][1]\nfunction maxProfit(prices: number[]): number {\n  const dp = new Array(prices.length).fill(0).map((_v) => new Array(4).fill(0));\n  dp[0][0] = -prices[0];\n  dp[0][1] = 0;\n  dp[0][2] = 0;\n  dp[0][3] = 0;\n  for (let i = 1; i < prices.length; i++) {\n    dp[i][0] = Math.max(\n      dp[i - 1][0],\n      dp[i - 1][2] - prices[i],\n      dp[i - 1][3] - prices[i]\n    );\n    dp[i][1] = dp[i - 1][0] + prices[i];\n    dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][3]);\n    dp[i][3] = dp[i - 1][1];\n  }\n  return Math.max(...dp[prices.length - 1]);\n}\n\n// 这里如果要做空间优化，需要去做赋值顺序的调整\n",
            "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/",
            "sortKey": 26
          },
          {
            "name": "27.买卖股票的最佳时机含手续费.ts",
            "type": "file",
            "path": "src/8.动态规划/27.买卖股票的最佳时机含手续费.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/\n */\nexport {};\n\n// dp[i][0]表示持有股票拥有的最大利润\n// dp[i][1]表示不持有股票拥有的最大利润\n// TODO:探索一下如何debugger，因为目前dp状态越来越复杂，只能手动模拟数值了。然后看对应的。\nfunction maxProfit(prices: number[], fee: number): number {\n  const dp = new Array(prices.length).fill(0).map((_v) => new Array(2).fill(0));\n  dp[0][0] = -prices[0];\n  dp[0][1] = 0;\n  for (let i = 1; i < prices.length; i++) {\n    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);\n  }\n  console.table(dp);\n\n  return dp[prices.length - 1][1];\n}\n\nmaxProfit([1, 3, 2, 8, 4, 9], 2);\n",
            "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/",
            "sortKey": 27
          },
          {
            "name": "28.最长递增子序列.ts",
            "type": "file",
            "path": "src/8.动态规划/28.最长递增子序列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/longest-increasing-subsequence/description/\n */\n// function lengthOfLIS(nums: number[]): number {}\n\n// notice：找出所有的递增子序列,回溯法暴力搜索\n// TODO:思考一下暴力搜索\n\n// function lengthOfLIS(nums: number[]): number {\n//     const res: number[][] = []\n//     const dfs = (path: number[], startIndex: number) => {\n//         const set: Set<number> = new Set()\n\n//         if (path[path.length - 1] <= path[path.length - 2]) {\n//             path.pop()\n//             res.push(path.concat())\n//             return\n//         }\n//         if (startIndex >= nums.length) {\n//             res.push(path.concat())\n//             return\n//         }\n//         for (let i = startIndex; i < nums.length; i++) {\n//             if (set.has(nums[i])) {\n//                 continue\n//             }\n\n//             path.push(nums[i])\n//             set.add(nums[i])\n//             dfs(path.concat(), i + 1)\n//             path.pop()\n//         }\n//     }\n//     const findMax = (arr: number[][]) => {\n//         let max = Number.MIN_SAFE_INTEGER\n//         arr.forEach((_v) => {\n//             max = Math.max(_v.length, max)\n//         })\n//         return max\n//     }\n//     dfs([], 0)\n\n//     return findMax(res)\n// }\n\n// console.log(lengthOfLIS([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]))\n\n// TODO:动态规划\n// dp[i]表示到达第i个位置所能获得的最长递增子序列\n// dp[i] = dp[j]+1 nums[i] > nums[j]\nfunction lengthOfLIS(nums: number[]): number {\n  const dp = new Array(nums.length).fill(1); // 初始化的时候注意一点\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j]) {\n        dp[i] = Math.max(dp[j] + 1, dp[i]);\n      }\n    }\n  }\n  return Math.max(...dp);\n}\n// console.log(lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]))\n",
            "url": "https://leetcode.cn/problems/longest-increasing-subsequence/description/",
            "sortKey": 28
          },
          {
            "name": "29.最长连续递增子序列.ts",
            "type": "file",
            "path": "src/8.动态规划/29.最长连续递增子序列.ts",
            "content": "// @ts-nocheck\n/**\n * @url https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/\n */\n\n// dp[i]表示到第i个位置的连续子序列的长度\nfunction findLengthOfLCIS(nums: number[]): number {\n  const dp = new Array(nums.length).fill(1);\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > nums[i - 1]) {\n      dp[i] = Math.max(dp[i - 1] + 1, dp[i]);\n    }\n  }\n  return Math.max(...dp);\n}\n\n// ps:暴力解法如下\n\nfunction lengthOfLIS(nums) {\n  if (!nums || nums.length === 0) return 0;\n\n  let maxLen = 0; // 全局变量，记录最长递增子序列长度\n\n  function backtrack(index, currSeq) {\n    // 更新最长长度\n    maxLen = Math.max(maxLen, currSeq.length);\n\n    // 从当前索引往后遍历\n    for (let i = index; i < nums.length; i++) {\n      // 如果当前元素可以加入递增子序列\n      if (currSeq.length === 0 || nums[i] > currSeq[currSeq.length - 1]) {\n        // 选择：加入当前元素\n        currSeq.push(nums[i]);\n        // 递归探索后续元素\n        backtrack(i + 1, currSeq);\n        // 回溯：撤销选择\n        currSeq.pop();\n      }\n      // 不选择当前元素的情况会自动通过循环继续\n    }\n  }\n\n  backtrack(0, []);\n  return maxLen;\n}\n",
            "url": "https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/",
            "sortKey": 29
          },
          {
            "name": "30.最长重复子数组.ts",
            "type": "file",
            "path": "src/8.动态规划/30.最长重复子数组.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/\n */\n\n// TODO:dp[i][j]表示以num1[i]为末尾项，末尾项为nums2[j]的子数组\n// PS:注意一下dp[i][j]的定义，dp[i][j]表示以num1[i]为末尾项，末尾项为nums2[j]的子数组\n// nums[i] nums[j]\n// 优化点：init初始化可以简洁一点，不用手动去初始化\n\nfunction findLength(nums1: number[], nums2: number[]): number {\n  const dp = new Array(nums1.length)\n    .fill(0)\n    .map((_v) => new Array(nums2.length).fill(0));\n  let res = Number.MIN_SAFE_INTEGER;\n  for (let i = 0; i < nums1.length; i++) {\n    if (nums1[i] === nums2[0]) {\n      dp[i][0] = 1;\n      res = 1;\n    }\n  }\n  for (let i = 0; i < nums2.length; i++) {\n    if (nums2[i] === nums1[0]) {\n      dp[0][i] = 1;\n      res = 1;\n    }\n  }\n\n  for (let i = 1; i < nums1.length; i++) {\n    for (let j = 1; j < nums2.length; j++) {\n      if (nums1[i] === nums2[j]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      }\n      res = Math.max(res, dp[i][j]);\n    }\n  }\n  console.table(dp);\n  return res === Number.MIN_SAFE_INTEGER ? 0 : res;\n}\nfindLength([1, 2, 3, 2, 1], [3, 2, 1, 2, 7]);\n\n// 12321\n// 32127\n",
            "url": "https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/",
            "sortKey": 30
          },
          {
            "name": "31.最长公共子序列.ts",
            "type": "file",
            "path": "src/8.动态规划/31.最长公共子序列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/longest-common-subsequence/description/\n */\n\n// dp[i][j] 表示text1以i-1为下标，text2以j-1为下标的最长公共子序列\n// dp[i][j] = dp[i-1][j-1] + 1\n// TODO:30,31再好好思索一下  连续性和不连续的区别， 可以通过思考下一个状态的依赖来思考变化\n// - 状态被截断\n// - 状态已经截断\n// - 初始化和最长重复子数组不太一样\nfunction longestCommonSubsequence(text1: string, text2: string): number {\n  const dp = new Array(text1.length + 1)\n    .fill(0)\n    .map((_v) => new Array(text2.length + 1).fill(0));\n  let res = Number.MIN_SAFE_INTEGER;\n  for (let i = 1; i <= text1.length; i++) {\n    for (let j = 1; j <= text2.length; j++) {\n      if (text1[i - 1] === text2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n      }\n      res = Math.max(res, dp[i][j]);\n    }\n  }\n\n  return res;\n}\nlongestCommonSubsequence(\"abc\", \"def\");\n",
            "url": "https://leetcode.cn/problems/longest-common-subsequence/description/",
            "sortKey": 31
          },
          {
            "name": "32.最大子数组和.ts",
            "type": "file",
            "path": "src/8.动态规划/32.最大子数组和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/maximum-subarray/description/\n */\n\n// dp[i]表示下标为i结尾的子数组的最大和\n// dp[i] = dp[i-1],\nfunction maxSubArray(nums: number[]): number {\n    const dp = new Array(nums.length).fill(0)\n    dp[0] = nums[0]\n    for (let i = 1; i < nums.length; i++) {\n        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])\n    }\n    console.log(dp)\n    return Math.max(...dp)\n}\n// console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))\n",
            "url": "https://leetcode.cn/problems/maximum-subarray/description/",
            "sortKey": 32
          },
          {
            "name": "33.判断子序列.ts",
            "type": "file",
            "path": "src/8.动态规划/33.判断子序列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/is-subsequence/description/\n */\n\n// TODO:双指针来判断\n// TODO:动态规划\n// abc\n// abcdef\n// dp[i][j]表示以s[i-1]为结尾,t[j-1]为结尾最长公共子序列\n// s[i-1]===t[j-1]?dp[i-1][j-1]+1:dp[i][j-1] ac addddc\n// notice:删除s的话一定是比删除t匹配结果更少的（这里也可以理解为剪枝的操作）\n// 结果比较最长公共子序列的长度是否和s的长度相等\nfunction isSubsequence(s: string, t: string): boolean {\n  if (s.length < 1) {\n    return true;\n  }\n  const dp = new Array(s.length + 1)\n    .fill(0)\n    .map((_item) => new Array(t.length + 1).fill(0));\n  dp[0][0] = 0;\n  dp[1][0] = 0;\n  dp[0][1] = 0;\n  for (let i = 1; i < s.length + 1; i++) {\n    for (let j = 1; j < t.length + 1; j++) {\n      if (s[i - 1] === t[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      } else {\n        dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);\n      }\n    }\n  }\n  return dp[s.length][t.length] === s.length;\n}\n",
            "url": "https://leetcode.cn/problems/is-subsequence/description/",
            "sortKey": 33
          },
          {
            "name": "34.不同的子序列.ts",
            "type": "file",
            "path": "src/8.动态规划/34.不同的子序列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/distinct-subsequences/\n */\n\n// s的子序列中t出现的个数 baggg bag\n// notice:思考：为啥不是累加，而是前一次的和再加入的？\n// dp[i][j] 以s[i-1],t[j-1]为结尾的t出现的个数 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n// 每一次状态 + 上一次未比较的状态 可以举一个t的长度为1的例子\nfunction numDistinct(s: string, t: string): number {\n    const dp = new Array(s.length + 1).fill(0).map((_v) => new Array(t.length + 1).fill(0))\n    for (let i = 0; i <= s.length; i++) {\n        dp[i][0] = 1\n    }\n    for (let i = 1; i < s.length + 1; i++) {\n        for (let j = 1; j < t.length + 1; j++) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            } else {\n                dp[i][j] = dp[i - 1][j]\n            }\n        }\n    }\n\n    console.table(dp)\n\n    return dp[s.length][t.length]\n}\n\nnumDistinct(\"babgbag\", \"bag\")\n",
            "url": "https://leetcode.cn/problems/distinct-subsequences/",
            "sortKey": 34
          },
          {
            "name": "35.两个字符串的删除操作.ts",
            "type": "file",
            "path": "src/8.动态规划/35.两个字符串的删除操作.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/delete-operation-for-two-strings/description/\n */\nexport {}\n// aab  aac\n// dp[i][j]表示以word1[i-1]为结尾和以word2[i-1]为结尾的最长公共子序列的长度\n// 相等 dp[i][j] = dp[i-1][j-1]+1\n// 不相等的话：dp[i][j] = max~dp[i-1][j],dp[i][j-1]\nfunction minDistance(word1: string, word2: string): number {\n    const dp = new Array(word1.length + 1).fill(0).map((_v) => new Array(word2.length + 1).fill(0))\n\n    for (let i = 1; i <= word1.length; i++) {\n        for (let j = 1; j <= word2.length; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    console.table(dp)\n\n    return (\n        Math.abs(dp[word1.length][word2.length] - word1.length) +\n        Math.abs(dp[word1.length][word2.length] - word2.length)\n    )\n}\n",
            "url": "https://leetcode.cn/problems/delete-operation-for-two-strings/description/",
            "sortKey": 35
          },
          {
            "name": "36.编辑距离.ts",
            "type": "file",
            "path": "src/8.动态规划/36.编辑距离.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/edit-distance/description/\n */\n\nexport {}\n// function minDistance(word1: string, word2: string): number {\n//     const dp = new Array(word1.length + 1).fill(0).map((_v) => new Array(word2.length + 1).fill(0))\n\n//     for (let i = 1; i <= word1.length; i++) {\n//         for (let j = 1; j <= word2.length; j++) {\n//             if (word1[i - 1] === word2[j - 1]) {\n//                 dp[i][j] = dp[i - 1][j - 1] + 1\n//             } else {\n//                 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\n//             }\n//         }\n//     }\n//     const max = dp[word1.length][word2.length]\n\n//     if (word1.length > word2.length) {\n//         return Math.abs(word1.length - max)\n//     } else {\n//         return Math.abs(word2.length - max)\n//     }\n// }\n// notice：不要想着操作都为替换，注意子序列中间的相对顺序\n// intention\n// execution\n\n// console.log(minDistance(\"intention\", \"execution\"))\n\n// TODO:最长重复子数组试试，不行还是是相对顺序的原因\n\n// TODO:需要的最少操作\n// dp[0][0]= 0\nfunction minDistance(word1: string, word2: string): number {\n    const dp = new Array(word1.length + 1).fill(0).map((_v) => new Array(word2.length + 1).fill(0))\n    for (let i = 0; i <= word1.length; i++) {\n        dp[i][0] = i\n    }\n    for (let j = 0; j <= word2.length; j++) {\n        dp[0][j] = j\n    }\n    for (let i = 1; i <= word1.length; i++) {\n        for (let j = 1; j <= word2.length; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1]\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1)\n            }\n        }\n    }\n    return dp[word1.length][word2.length]\n}\n",
            "url": "https://leetcode.cn/problems/edit-distance/description/",
            "sortKey": 36
          },
          {
            "name": "37.回文子串.ts",
            "type": "file",
            "path": "src/8.动态规划/37.回文子串.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/palindromic-substrings/description/\n */\n// 示例 1：\n\n// 输入：s = \"abc\"\n// 输出：3\n// 解释：三个回文子串: \"a\", \"b\", \"c\"\n// 示例 2：\n\n// 输入：s = \"aaa\"\n// 输出：6\n// 解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\n\n// dp[i][j]表示以区间[i,j]的子串是否是回文字符串\n// s[i] === s[j]? dp[i][j] = dp[i+1][j-1]\n// abba a(1) ab(2) abb(3) abba(5)\nfunction countSubstrings(s: string): number {\n    const dp = new Array(s.length).fill(true).map((_v) => new Array(s.length).fill(false))\n    let res = 0\n\n    // notice：根据递推公式来确认遍历顺序，从下网上，从左往右\n    for (let i = s.length - 1; i >= 0; i--) {\n        for (let j = i; j < s.length; j++) {\n            if (s[i] === s[j]) {\n                if (j - i <= 1) {\n                    dp[i][j] = true\n                    res++\n                } else if (dp[i + 1][j - 1]) {\n                    dp[i][j] = true\n                    res++\n                }\n            }\n        }\n    }\n    return res\n}\n",
            "url": "https://leetcode.cn/problems/palindromic-substrings/description/",
            "sortKey": 37
          },
          {
            "name": "38.最长回文子序列.ts",
            "type": "file",
            "path": "src/8.动态规划/38.最长回文子序列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/longest-palindromic-subsequence/description/\n */\n// dp[i][j] 区间[i,j]之间的最长回文子序列 s[i]===s[j]? dp[i+1][j-1]+2: dp[i+1][j] dp[i][j-1]\nfunction longestPalindromeSubseq(s: string): number {\n    const dp = new Array(s.length).fill(0).map((_v) => new Array(s.length).fill(0))\n\n    for (let i = 0; i < s.length; i++) {\n        dp[i][i] = 1\n    }\n\n    for (let i = s.length - 1; i >= 0; i--) {\n        for (let j = i + 1; j < s.length; j++) {\n            if (s[i] === s[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            } else {\n                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n    }\n    return dp[0][s.length - 1]\n}\nlongestPalindromeSubseq(\"bbbab\")\n// ABCBDAB\n// BDCABA\n",
            "url": "https://leetcode.cn/problems/longest-palindromic-subsequence/description/",
            "sortKey": 38
          }
        ],
        "sortKey": 8
      },
      {
        "name": "9.贪心算法",
        "type": "directory",
        "path": "src/9.贪心算法",
        "children": [
          {
            "name": "1.分发饼干.ts",
            "type": "file",
            "path": "src/9.贪心算法/1.分发饼干.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/assign-cookies/description/\n */\n\n// notice:孩子不变，饼干是分发的\n// function findContentChildren(g: number[], s: number[]): number {\n//     const sort = (arr: number[]) => arr.sort((a, b) => a - b)\n\n//     let bottom = 0\n//     sort(g)\n//     sort(s)\n//     for (let i = 0; i < Math.min(s.length, g.length); i++) {\n//         if (s[bottom] >= g[i]) {\n//             bottom++\n//         }\n//     }\n//     return bottom\n// }\nfunction findContentChildren(g: number[], s: number[]): number {\n    const sort = (arr: number[]) => arr.sort((a, b) => a - b)\n    let child = 0\n    sort(g)\n    sort(s)\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] >= g[child]) {\n            child++\n        }\n    }\n\n    return child\n}\n",
            "url": "https://leetcode.cn/problems/assign-cookies/description/",
            "sortKey": 1
          },
          {
            "name": "2.摆动序列.ts",
            "type": "file",
            "path": "src/9.贪心算法/2.摆动序列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/wiggle-subsequence/description/\n */\n// nums = [1,7,4,9,2,5]\n// 输出：6\n// 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。\n\n// dp[i]表示以nums[i]为结尾的摆动序列的长度\n// nums[i]-nums[i-1]>0  判断nums[i-1]-nums[i-2]<0 反之  dp[i] = dp[i-1]+1  dp[i] = dp[i-1]\n// notice:还是状态考虑错了，这样并没有考虑前面是山峰还是山谷   25/31\n// function wiggleMaxLength(nums: number[]): number {\n//     const dp = new Array(nums.length).fill(0)\n//     if (nums.length < 2) {\n//         return 1\n//     }\n//     dp[0] = 1\n//     dp[1] = nums[1] === nums[0] ? 1 : 2\n//     if ((dp[1] - dp[0] > 0 && dp[2] - dp[1] < 0) || (dp[1] - dp[0] < 0 && dp[2] - dp[1] > 0)) {\n//         dp[2] = 3\n//     }\n//     for (let i = 2; i < nums.length; i++) {\n//         if (\n//             (nums[i] - nums[i - 1] > 0 && nums[i - 1] - nums[i - 2] < 0) ||\n//             (nums[i] - nums[i - 1] < 0 && nums[i - 1] - nums[i - 2] > 0)\n//         ) {\n//             dp[i] = dp[i - 1] + 1\n//         } else {\n//             dp[i] = dp[i - 1]\n//         }\n//     }\n//     console.table(dp)\n//     return Math.max(...dp)\n// }\n// wiggleMaxLength([84])\n\n// TODO:动态规划思路2\n// PS: 动态规划这里做会比较好理解\n// dp[i][0] = max(dp[i][0], dp[j][1] + 1)，其中0 < j < i且nums[j] < nums[i]，表示将 nums[i]接到前面某个山谷后面，作为山峰。\n// dp[i][1] = max(dp[i][1], dp[j][0] + 1)，其中0 < j < i且nums[j] > nums[i]，表示将 nums[i]接到前面某个山峰后面，作为山谷。\nfunction wiggleMaxLength(nums: number[]): number {\n  const dp = new Array(nums.length).fill(0).map((_v) => new Array(2).fill(0));\n  dp[0][0] = 1;\n  dp[0][1] = 1;\n  for (let i = 1; i < nums.length; i++) {\n    // 这里的初始化：两个数相等，算是一个数的情况的摆动序列\n    dp[i][0] = 1;\n    dp[i][1] = 1;\n    for (let j = 0; j < i; j++) {\n      if (nums[i] - nums[j] > 0) {\n        // 前面应该是谷底\n        dp[i][1] = Math.max(dp[j][0] + 1, dp[i][1]);\n      } else if (nums[i] - nums[j] < 0) {\n        dp[i][0] = Math.max(dp[j][1] + 1, dp[i][0]);\n      }\n    }\n  }\n  return Math.max(...dp[nums.length - 1]);\n}\n",
            "url": "https://leetcode.cn/problems/wiggle-subsequence/description/",
            "sortKey": 2
          },
          {
            "name": "3.最大子数组和.ts",
            "type": "file",
            "path": "src/9.贪心算法/3.最大子数组和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/maximum-subarray/\n */\n\n// 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n// 输出：6\n// 解释：连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n// dp[i]表示以nums[i-1]为结尾的最大子数组和 dp[i] = dp[i-1]+nums[i]\n// function maxSubArray(nums: number[]): number {\n//     const dp = new Array(nums.length + 1).fill(Number.MIN_SAFE_INTEGER)\n\n//     for (let i = 1; i <= nums.length; i++) {\n//         dp[i] = Math.max(dp[i - 1] + nums[i - 1], nums[i - 1])\n//     }\n//     console.table(dp)\n//     return Math.max(...dp)\n// }\n\n// TODO:贪心做法\nfunction maxSubArray(nums: number[]): number {\n  let count = 0, //统计目前累加的和\n    result = Number.MIN_SAFE_INTEGER; // 放置结果\n  for (let i = 0; i < nums.length; i++) {\n    count += nums[i];\n    if (count > result) {\n      result = count;\n    }\n    if (count < 0) {\n      count = 0;\n    }\n  }\n  return result;\n}\n",
            "url": "https://leetcode.cn/problems/maximum-subarray/",
            "sortKey": 3
          },
          {
            "name": "4.买卖股票的最佳时机 II.ts",
            "type": "file",
            "path": "src/9.贪心算法/4.买卖股票的最佳时机 II.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/\n */\n\n// 动态规划\n// dp[i][0]表示第i天手上有股票的最大利润 dp[i][0] = dp[i-1][1]-nums[i] dp[i][0]\n// dp[i][1]表示第i天手上没有股票的最大利润 dp[i][1] = dp[i-1][0]+nums[i] dp[i-1][1]\n// function maxProfit(prices: number[]): number {\n//     const dp = new Array(prices.length + 1).fill(0).map((_v) => new Array(2).fill(0))\n//     dp[0][0] = -prices[0] // TODO:换了下标，这里的初始化还是需要改变\n//     for (let i = 1; i <= prices.length; i++) {\n//         dp[i][0] = Math.max(dp[i - 1][1] - prices[i - 1], dp[i - 1][0])\n//         dp[i][1] = Math.max(dp[i - 1][0] + prices[i - 1], dp[i - 1][1])\n//     }\n//     console.table(dp)\n//     return dp[prices.length][1]\n// }\n// console.log(maxProfit([7, 1, 5, 3, 6, 4]))\n// 贪心算法\nfunction maxProfit(prices: number[]): number {\n  // 计算数组中的间隔\n  const init = (arr: number[]) => {\n    const temp: number[] = [];\n    for (let i = 1; i < arr.length; i++) {\n      temp.push(arr[i] - arr[i - 1]);\n    }\n    return temp;\n  };\n  const intervalArray = init(prices);\n  return intervalArray.reduce((acc, cur) => {\n    if (cur >= 0) {\n      return acc + cur;\n    }\n    return acc;\n  }, 0);\n}\n",
            "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/",
            "sortKey": 4
          },
          {
            "name": "5.跳跃游戏.ts",
            "type": "file",
            "path": "src/9.贪心算法/5.跳跃游戏.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/jump-game/description/\n */\n\n// 动态规划\n// dp【i】表示是否能够到达第i个位置\n// 从0开始 dp[j]+nums[j]是否大于i,大于就break\n// function canJump(nums: number[]): boolean {\n//     const dp = new Array(nums.length).fill(false)\n//     dp[0] = true\n//     for (let i = 1; i < nums.length; i++) {\n//         for (let j = 0; j < i; j++) {\n//             if (dp[j] && j + nums[j] >= i) {\n//                 dp[i] = true\n//                 break\n//             }\n//         }\n//     }\n//     // console.table(dp)\n//     return dp[nums.length - 1]\n// }\n// console.log(canJump([2, 3, 1, 1, 4]))\n// console.log(canJump([3, 2, 1, 0, 4]))\n\n// 贪心算法(编码很简洁，但是很巧妙不好想到)\n// 每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。\n// [2, 3, 1, 1, 4]\n\n// notice:错误，想象一下，后一次的范围依赖于前一次的范围是否能够达到\n// function canJump(nums: number[]): boolean {\n//     let maximumRange = 0\n//     for (let i = 0; i < nums.length - 1; i++) {\n//         maximumRange = Math.max(maximumRange, i + nums[i])\n//     }\n//     console.log(maximumRange)\n\n//     return maximumRange >= nums.length - 1\n// }\n// canJump([3, 2, 1, 0, 4])\nfunction canJump(nums: number[]): boolean {\n  let maximumRange = 0;\n  for (let i = 0; i <= maximumRange && i < nums.length; i++) {\n    maximumRange = Math.max(maximumRange, i + nums[i]);\n  }\n\n  return maximumRange >= nums.length - 1;\n}\n// canJump([2, 3, 1, 1, 4])\n",
            "url": "https://leetcode.cn/problems/jump-game/description/",
            "sortKey": 5
          },
          {
            "name": "6.跳跃游戏2.ts",
            "type": "file",
            "path": "src/9.贪心算法/6.跳跃游戏2.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/jump-game-ii/description/\n */\n\n// 输入: nums = [2,3,1,1,4]\n// 输出: 2\n// 解释: 跳到最后一个位置的最小跳跃数是 2。\n//      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n\n// dp[i]表示到达位置i的最小跳跃数\n// function jump(nums: number[]): number {\n//     const dp = new Array(nums.length).fill(Number.MAX_SAFE_INTEGER)\n//     dp[0] = 0\n//     for (let i = 1; i < nums.length; i++) {\n//         for (let j = 0; j < i; j++) {\n//             if (j + nums[j] >= i) {\n//                 dp[i] = Math.min(dp[i], dp[j] + 1)\n//             }\n//         }\n//     }\n//     return dp[nums.length - 1]\n// }\n\n// 贪心算法\nfunction jump(nums: number[]): number {\n    if (nums.length === 1) return 0\n    let steps = 0, //步数\n        currentScope = 0,\n        nextStepScope = 0\n    for (let i = 0; i < nums.length; i++) {\n        nextStepScope = Math.max(nextStepScope, i + nums[i])\n        if (i === currentScope) {\n            steps++\n            currentScope = nextStepScope\n            if (nextStepScope >= nums.length - 1) {\n                break\n            }\n        }\n    }\n    return steps\n}\n",
            "url": "https://leetcode.cn/problems/jump-game-ii/description/",
            "sortKey": 6
          },
          {
            "name": "7.k次取反化后最大化的数组和.ts",
            "type": "file",
            "path": "src/9.贪心算法/7.k次取反化后最大化的数组和.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/\n */\n\n// 优先负数，然后最小的正数\n// notice：这种算法是只能选择一次\n// function largestSumAfterKNegations(nums: number[], k: number): number {\n//     nums.sort((a, b) => a - b)\n//     let idx = 0\n//     while (k--) {\n//         nums[idx] = -nums[idx]\n//         idx++\n//     }\n//     return nums.reduce((acc, cur) => acc + cur, 0)\n// }\n\n// 优先负数，然后对于最小的正数进行反转\n// TODO:可以优化一下时间复杂度\n\n// function largestSumAfterKNegations(nums: number[], k: number): number {\n//     while (k--) {\n//         nums.sort((a, b) => a - b)\n//         let index = nums.findIndex((_num) => _num < 0)\n//         nums[index] *= -1\n\n//         if (index === -1) {\n//             nums.sort((a, b) => a - b)\n//             nums[0] *= -1\n//         }\n//     }\n//     return nums.reduce((acc, cur) => acc + cur, 0)\n// }\n\nfunction largestSumAfterKNegations(nums: number[], k: number): number {\n  nums.sort((a, b) => a - b);\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 0 && k > 0) {\n      nums[i] *= -1;\n      k--;\n    }\n  }\n  nums.sort((a, b) => a - b); // PS: 注意二次排序\n  if (k % 2 === 1) {\n    nums[0] *= -1;\n  }\n  return nums.reduce((acc, cur) => acc + cur, 0);\n}\n",
            "url": "https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/",
            "sortKey": 7
          },
          {
            "name": "8.加油站.ts",
            "type": "file",
            "path": "src/9.贪心算法/8.加油站.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/gas-station/description/\n */\n\n// -2 -2  -2 3 3\n// notice：考虑错了,并不是从剩余中最大的出去就是好的\n// function canCompleteCircuit(gas: number[], cost: number[]): number {\n//     const arr: number[] = [] // 表示arr[i]前往i+1站剩余的邮费\n//     for (let i = 0; i < gas.length; i++) {\n//         arr.push(gas[i] - cost[i])\n//     }\n//     console.log(arr)\n//     let maxIndex = arr.indexOf(Math.max(...arr))\n//     let curIndex = maxIndex\n//     let count = 0,\n//         curNum = 0\n//     while (count < gas.length) {\n//         count++\n//         curNum += arr[curIndex % gas.length]\n//         console.log(count, gas.length, \"cur\")\n\n//         if (curNum <= 0 && count !== gas.length) {\n//             return -1\n//         }\n//         curIndex++\n//     }\n\n//     return maxIndex\n// }\n// console.log(canCompleteCircuit([5, 8, 2, 8], [6, 5, 6, 6]))\n\n// TODO:暴力解法,超时了。技巧：环形链表用while来遍历比较好\n// function canCompleteCircuit(gas: number[], cost: number[]): number {\n//     const arr: number[] = [] // 表示arr[i]前往i+1站剩余的邮费\n//     let result = -1\n//     for (let i = 0; i < gas.length; i++) {\n//         arr.push(gas[i] - cost[i])\n//     }\n//     for (let i = 0; i < gas.length; i++) {\n//         let curIndex = i,\n//             count = gas.length,\n//             res = 0,\n//             isPass = true\n//         while (count--) {\n//             res += arr[curIndex++ % gas.length]\n//             if (res < 0) {\n//                 isPass = false\n//                 break\n//             }\n//         }\n//         if (isPass) {\n//             result = curIndex % gas.length\n//             break\n//         }\n//     }\n//     return result\n// }\n\n// *贪心:总数只要大于0一定就可以走完，看看从什么时候开始小于0，然后更新起始的下标索引。\nfunction canCompleteCircuit(gas: number[], cost: number[]): number {\n  const arr: number[] = []; // 表示arr[i]前往i+1站剩余的邮费\n  for (let i = 0; i < gas.length; i++) {\n    arr.push(gas[i] - cost[i]);\n  }\n  let startIndex = 0,\n    totalSum = 0,\n    curSum = 0;\n  for (let i = 0; i < gas.length; i++) {\n    curSum += arr[i];\n    totalSum += arr[i];\n    if (curSum < 0) {\n      startIndex = i + 1;\n      curSum = 0;\n    }\n  }\n  if (totalSum < 0) return -1;\n  return startIndex;\n}\n",
            "url": "https://leetcode.cn/problems/gas-station/description/",
            "sortKey": 8
          },
          {
            "name": "9.分发糖果.ts",
            "type": "file",
            "path": "src/9.贪心算法/9.分发糖果.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/candy/description/\n */\n\n// notice：先考虑一遍，然后再进行整合\nfunction candy(ratings: number[]): number {\n  const res = new Array(ratings.length).fill(1);\n  // 确定右孩子比左孩子大的情况\n  for (let i = 1; i < ratings.length; i++) {\n    if (ratings[i] > ratings[i - 1]) {\n      res[i] = res[i - 1] + 1;\n    }\n  }\n  console.log(\"res\", res);\n\n  // 确定左孩子比右孩子大，倒序遍历，因为要用到后面先比较的结果\n  for (let i = ratings.length - 2; i >= 0; i--) {\n    if (ratings[i] > ratings[i + 1]) {\n      res[i] = Math.max(res[i], res[i + 1] + 1);\n    }\n  }\n  console.log(res);\n\n  return res.reduce((acc, cur) => acc + cur, 0);\n}\ncandy([1, 0, 2]);\n",
            "url": "https://leetcode.cn/problems/candy/description/",
            "sortKey": 9
          },
          {
            "name": "10.柠檬水找零.ts",
            "type": "file",
            "path": "src/9.贪心算法/10.柠檬水找零.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/lemonade-change/description/\n */\n\n// [5,5,5,10,20]\n// 返回的时候，优先返回面额大的\n\n// 账单只会支付20元,账单为20元的判断错误了\n// function lemonadeChange(bills: number[]): boolean {\n//     const map = new Array(3).fill(0) // 分别表示5元钞票，10元钞票，15元钞票的张数\n//     for (let i = 0; i < bills.length; i++) {\n//         if (bills[i] === 20) {\n//             if (map[1] <= 0 || map[0] <= 0) {\n//                 return false\n//             }\n//             map[1]--\n//             map[0]--\n//             map[2]++\n//         } else if (bills[i] === 10) {\n//             if (map[0] <= 0) {\n//                 return false\n//             }\n//             map[1]++\n//             map[0]--\n//         } else {\n//             map[0]++\n//         }\n//     }\n//     return true\n// }\n\n// 贪心的策略就是当20的时候，优先去找10元的\nfunction lemonadeChange(bills: number[]): boolean {\n    const map = new Array(3).fill(0) // 分别表示5元钞票，10元钞票，15元钞票的张数\n    for (let i = 0; i < bills.length; i++) {\n        if (bills[i] === 20) {\n            if (map[1] <= 0) {\n                if (map[0] < 3) {\n                    return false\n                }\n                map[0] -= 3\n            } else {\n                if (map[0] <= 0) {\n                    return false\n                }\n                map[0]--\n                map[1]--\n                map[2]++\n            }\n        } else if (bills[i] === 10) {\n            if (map[0] <= 0) {\n                return false\n            }\n            map[1]++\n            map[0]--\n        } else {\n            map[0]++\n        }\n    }\n    return true\n}\n",
            "url": "https://leetcode.cn/problems/lemonade-change/description/",
            "sortKey": 10
          },
          {
            "name": "11.根据身高重建队列.ts",
            "type": "file",
            "path": "src/9.贪心算法/11.根据身高重建队列.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/queue-reconstruction-by-height/description/\n */\n\n// notice：题意剖析：给一个随意排序的数组，根据数组中的特性进行重建\n// 贪心：people[i][1]越小的人在越前面么？❎\n// TODO:本题两个维度，一定是先确认其中一个维度，可以尝试一下（本题先将身高确认下来，再来改变数组，确认k）\n\n// [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n// [ [ 7, 0 ], [ 7, 1 ], [ 6, 1 ], [ 5, 0 ], [ 5, 2 ], [ 4, 4 ] ]\n// notice:排序有点问题\n// function reconstructQueue(people: number[][]): number[][] {\n//     people.sort((a, b) => b[0] - a[0])\n//     for (let i = 0; i < people.length; i++) {\n//         people.splice(i, 1)\n//         people.splice(people[i][1], 0, people[i])\n//     }\n//     return people\n// }\n\nfunction reconstructQueue(people: number[][]): number[][] {\n  people.sort((a, b) => {\n    // 身高相等，h大的放后面\n    if (a[0] === b[0]) {\n      return a[1] - b[1];\n    }\n    return b[0] - a[0];\n  });\n\n  const res = people.concat();\n\n  for (let i = 0; i < people.length; i++) {\n    res.splice(i, 1);\n    res.splice(people[i][1], 0, people[i]);\n  }\n  return res;\n}\n\nconsole.log(\n  reconstructQueue([\n    [7, 0],\n    [4, 4],\n    [7, 1],\n    [5, 0],\n    [6, 1],\n    [5, 2],\n  ])\n);\n",
            "url": "https://leetcode.cn/problems/queue-reconstruction-by-height/description/",
            "sortKey": 11
          },
          {
            "name": "12.用最小数量的箭引爆气球.ts",
            "type": "file",
            "path": "src/9.贪心算法/12.用最小数量的箭引爆气球.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/\n */\n\n// 升序--> 处理最小公共区间，记录有多少区间\n// notice:其实就是找非重叠区间的个数\nfunction findMinArrowShots(points: number[][]): number {\n  let count = 0,\n    section = new Array(2).fill(0);\n\n  points.sort((a, b) => a[0] - b[0]);\n  for (let i = 0; i < points.length; i++) {\n    if (i === 0) {\n      section[0] = points[i][0];\n      section[1] = points[i][1];\n      count++;\n      continue;\n    }\n    if (points[i][0] > section[1]) {\n      count++;\n      section[0] = points[i][0];\n      section[1] = points[i][1];\n    } else {\n      section[0] = points[i][0];\n      section[1] = Math.min(points[i][1], section[1]);\n    }\n  }\n  return count;\n}\n",
            "url": "https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/",
            "sortKey": 12
          },
          {
            "name": "13.无重叠区间.ts",
            "type": "file",
            "path": "src/9.贪心算法/13.无重叠区间.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/non-overlapping-intervals/description/\n */\n// 本题和上题的区别就是求重叠区间的最小个数\n// notice：因为是排序之后，所以只需要关注右边界\n// TODO:思考一下边界情况,怎么去判断的。\nfunction eraseOverlapIntervals(intervals: number[][]): number {\n    intervals.sort((a, b) => a[0] - b[0])\n\n    let count = 0,\n        rightInterval = intervals[0][1]\n\n    for (let i = 1; i < intervals.length; i++) {\n        // 左边界小于上一次的右边界，说明有一次的重叠区域\n        if (intervals[i][0] < rightInterval) {\n            console.log(intervals[i], rightInterval)\n            count++\n            rightInterval = Math.min(rightInterval, intervals[i][1])\n        } else {\n            rightInterval = intervals[i][1]\n        }\n    }\n    return count\n}\n\nconsole.log(\n    eraseOverlapIntervals([\n        [1, 2],\n        [2, 3],\n        [3, 4],\n        [-100, -2],\n        [5, 7],\n    ])\n)\n",
            "url": "https://leetcode.cn/problems/non-overlapping-intervals/description/",
            "sortKey": 13
          },
          {
            "name": "14.划分字母区间.ts",
            "type": "file",
            "path": "src/9.贪心算法/14.划分字母区间.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/partition-labels/description/\n */\n\n// \"ababcbacadefegdehijhklij\"\n// 例如找到a，需要找到a的某尾，以此类推，一直往后遍历，直到遍历到end+1\n// 贪心策略：找到一段字符串的最末尾，然后截断。每次都是最小的一段，最后结果就是截断成各个最小的一段。\nfunction partitionLabels(s: string): number[] {\n  let rightIndex = 0,\n    lastIndex = 0,\n    res: number[] = [];\n  const findStrLastIndex = (str: string) => {\n    return s.lastIndexOf(str);\n  };\n  for (let i = 0; i < s.length; i++) {\n    if (i > rightIndex) {\n      res.push(rightIndex - lastIndex + 1);\n      lastIndex = rightIndex + 1; // PS:lastIndex===rightIndex的话，会重复计算一次！！！\n    }\n    rightIndex = Math.max(findStrLastIndex(s[i]), rightIndex);\n  }\n  // console.log(rightIndex, lastIndex)\n  res.push(rightIndex - lastIndex + 1);\n  return res;\n}\n// console.log(partitionLabels(\"aaaaabbbb\"))\n",
            "url": "https://leetcode.cn/problems/partition-labels/description/",
            "sortKey": 14
          },
          {
            "name": "15.合并区间.ts",
            "type": "file",
            "path": "src/9.贪心算法/15.合并区间.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/merge-intervals/description/\n */\n\n// 示例 1：\n\n// 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n// 输出：[[1,6],[8,10],[15,18]]\n// 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\nfunction merge(intervals: number[][]): number[][] {\n    intervals.sort((a, b) => a[0] - b[0]) // 先排序最左边\n    let rightIndex = intervals[0][1], // 记录右区间\n        leftIndex = intervals[0][0],\n        res: number[][] = []\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] <= rightIndex) {\n            // 说明区间被重合\n            rightIndex = Math.max(rightIndex, intervals[i][1]) // 注意取最大区间\n        } else {\n            res.push([leftIndex, rightIndex])\n            leftIndex = intervals[i][0]\n            rightIndex = intervals[i][1]\n        }\n    }\n    res.push([leftIndex, rightIndex])\n    return res\n}\n",
            "url": "https://leetcode.cn/problems/merge-intervals/description/",
            "sortKey": 15
          },
          {
            "name": "16.单调递增的数字.ts",
            "type": "file",
            "path": "src/9.贪心算法/16.单调递增的数字.ts",
            "content": "/**\n * @url https://leetcode.cn/problems/monotone-increasing-digits/description/\n */\n\n// 当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。\n// 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。\n// TODO:遍历顺序，从前到后，不能利用上次已经改变的结果！！！！比如1009 123329，体会一下  从前到后遍历，也会影响前面相应的比较\n// notice:这样的方法，没有考虑到前面改变了，后面会改变。应该统一将后面改为9\n// function monotoneIncreasingDigits(n: number): number {\n//     const arr = n\n//         .toString()\n//         .split(\"\")\n//         .map((_num) => Number.parseInt(_num))\n//     for (let i = arr.length - 2; i >= 0; i--) {\n//         if (arr[i] > arr[i + 1]) {\n//             arr[i] -= 1\n//             arr[i + 1] = 9\n//         }\n//     }\n//     return Number.parseInt(arr.join(\"\"))\n// }\n// TODO:细节挺多的\nfunction monotoneIncreasingDigits(n: number): number {\n    const arr = n\n        .toString()\n        .split(\"\")\n        .map((_num) => Number.parseInt(_num))\n    let flag = arr.length\n    for (let i = arr.length - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            arr[i] -= 1\n            flag = i + 1\n        }\n    }\n    for (let i = flag; i < arr.length; i++) {\n        arr[i] = 9\n    }\n    return Number.parseInt(arr.join(\"\"))\n}\n",
            "url": "https://leetcode.cn/problems/monotone-increasing-digits/description/",
            "sortKey": 16
          }
        ],
        "sortKey": 9
      },
      {
        "name": "10.前端相关手写",
        "type": "directory",
        "path": "src/10.前端相关手写",
        "children": [
          {
            "name": "1.实现js原生方法",
            "type": "directory",
            "path": "src/10.前端相关手写/1.实现js原生方法",
            "children": [
              {
                "name": "1.filter.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/1.filter.js",
                "content": "// Notice:回调函数没有this\n// Array.prototype.myFilter = (callback) => {\n//     console.log(this)\n//     const result = []\n//     for (let i = 0; i < this.length; i++) {\n//         console.log(callback(this[i]))\n//         if (callback(this[i], i, this)) {\n//             result.push(this[i])\n//         }\n//     }\n//     return result\n// }\n\n// 普通遍历实现\n// Array.prototype.myFilter = function (callback) {\n//     const result = []\n//     for (let i = 0; i < this.length; i++) {\n//         if (callback(this[i], i, this)) {\n//             result.push(this[i])\n//         }\n//     }\n//     return result\n// }\n\n// reduce来实现\nArray.prototype.myFilter = function (callback) {\n    return this.reduce((acc, cur, index) => {\n        if (callback(cur, index)) {\n            acc.push(cur)\n        }\n        return acc\n    }, [])\n}\nlet arr = [1, 2, 3, 4, 5]\narr = arr.myFilter((item) => {\n    return item >= 3\n})\nconsole.log(arr)\n",
                "url": "",
                "sortKey": 1
              },
              {
                "name": "2.flat.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/2.flat.js",
                "content": "Array.prototype.myFlat = function(depth){\n    const res = []\n    const dfs = (arr, leval)=>{\n        for (let i = 0; i < arr.length; i++) {\n            if(Array.isArray(arr[i])){\n                if (leval === depth) {\n                    res.push(arr[i])\n                    return\n                }\n                dfs(arr[i], leval + 1)\n            }else{\n                res.push(arr[i])\n            }\n        }\n    }\n    dfs(this, 1)\n    return res\n}\n\n\n// 有点小混乱\nlet arr = [1, 2, 3, [3, 2, [1, 2, 3]]]\nconsole.log(arr.myFlat(2))\n",
                "url": "",
                "sortKey": 2
              },
              {
                "name": "3.forEach.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/3.forEach.js",
                "content": "Array.prototype._forEach = function (callback) {\n    for (let i = 0; i < this.length; i++) {\n        callback(this[i], i, this)\n    }\n}\n",
                "url": "",
                "sortKey": 3
              },
              {
                "name": "4.map.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/4.map.js",
                "content": "Array.prototype._map = function (callback) {\n    return this.reduce((acc, cur, index) => {\n        acc.push(callback(cur, index, this))\n        return acc\n    }, [])\n}\nconst res = [2, 3, 4]\nconsole.log(res._map((_v) => _v ** 2))\n",
                "url": "",
                "sortKey": 4
              },
              {
                "name": "5.reduce.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/5.reduce.js",
                "content": "Array.prototype._reduce = function (callback, initValue) {\n    let res = initValue\n    for (let i = 0; i < this.length; i++) {\n        res = callback(res, this[i], i)\n    }\n    return res\n}\nlet arr = [1, 2, 3, 4, 5]\nconsole.log(\n    arr._reduce((acc, cur) => {\n        return acc + cur\n    }, 0)\n)\n",
                "url": "",
                "sortKey": 5
              },
              {
                "name": "6.fill.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/6.fill.js",
                "content": "Array.prototype._fill = function (value, start, end) {\n    start = start < 0 ? 0 : start\n    end = end > this.length - 1 ? this.length - 1 : end\n    for (let i = start; i <= end; i++) {\n        this[i] = value\n    }\n    return this\n}\nlet arr = [1, 2, 3, 4, 5]\nconsole.log(arr._fill(6, 2, 5))\n",
                "url": "",
                "sortKey": 6
              },
              {
                "name": "7.includes.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/7.includes.js",
                "content": "Array.prototype._includes = function (value) {\n    for (let i = 0; i < this.length; i++) {\n        if (this[i] === value) {\n            return true\n        }\n    }\n    return false\n}\nlet arr = [1, 2, 3, 4, 5]\nconsole.log(arr._includes(3))\nconsole.log(arr._includes(6))\n",
                "url": "",
                "sortKey": 7
              },
              {
                "name": "8.push.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/8.push.js",
                "content": "Array.prototype._push = function (value) {\n    this[this.length] = value\n    return this.length // 注意返回值\n}\nlet arr = [1, 2, 3, 4, 5]\narr._push(6)\nconsole.log(arr)\n",
                "url": "",
                "sortKey": 8
              },
              {
                "name": "9.unshift.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/9.unshift.js",
                "content": "Array.prototype._unshift = function (value) {\n    for (let i = this.length - 1; i >= 0; i--) {\n        this[i + 1] = this[i]\n    }\n    this[0] = value\n    return this.length\n}\nlet arr = [1, 2, 3, 4, 5]\narr._unshift(0)\nconsole.log(arr)\n",
                "url": "",
                "sortKey": 9
              },
              {
                "name": "10.getLeval.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/10.getLeval.js",
                "content": "Array.prototype.getLeval = function () {\n    let depth = 1\n    const dfs = (arr) => {\n        for (let i = 0; i < arr.length; i++) {\n            if (Array.isArray(arr[i])) {\n                depth++\n                dfs(arr[i])\n            }\n        }\n    }\n    dfs(this)   \n    return depth\n}\n\nlet arr = [1, 2, 3, [4, [5]]]\nconsole.log(arr.getLeval())\n",
                "url": "",
                "sortKey": 10
              },
              {
                "name": "11.interator.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/11.interator.js",
                "content": "// 实现迭代器\n// Array.prototype._interator = function () {\n//     let i = 0\n//     return {\n//         next: () => {\n//             return {\n//                 value: this[i++],\n//                 done: i < this.length ? false : true,\n//             }\n//         },\n//     }\n// }\n// let arr = [1, 2, 3, 4, 5]\n// const b = arr._interator()\n// console.log(b.next())\n// console.log(b.next())\n// console.log(b.next())\n// console.log(b.next())\n// console.log(b.next())\nlet obj = {\n    [Symbol.iterator]() {\n        return {\n            i: 0,\n            next() {\n                if (this.i < 5) {\n                    return {\n                        value: this.i++,\n                        done: false\n                    }\n                }\n                return { value: undefined, done: true }\n            }\n        }\n    }\n}\n\n// 测试\nfor (let i of obj) {\n    console.log(\"i\", i)  // 依次输出 0,1,2,3,4\n}\n",
                "url": "",
                "sortKey": 11
              },
              {
                "name": "12.sort.TODO.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/12.sort.TODO.js",
                "content": "// TODO:复习完排序算法，再来复习sort函数\nArray.prototype._sort = function (callback) {}\n",
                "url": "",
                "sortKey": 12
              },
              {
                "name": "13.Set.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/13.Set.js",
                "content": "",
                "url": "",
                "sortKey": 13
              },
              {
                "name": "14.Map.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/14.Map.js",
                "content": "",
                "url": "",
                "sortKey": 14
              },
              {
                "name": "15.assign.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/15.assign.js",
                "content": "Object.prototype._assign = function (target, ...source) {\n    source.forEach((_obj) => {\n        for (let key in _obj) {\n            if (target.hasownProperty(key)) {\n                target[key] = _obj[key]\n            } else {\n                target[key] = _obj[key]\n            }\n        }\n    })\n    return target\n}\nlet a = { a: 1 }\nlet b = { b: 2 }\nlet c = { c: 3 }\nconsole.log(Object.assign(a, b, c))\nconsole.log(a)\n",
                "url": "",
                "sortKey": 15
              },
              {
                "name": "16.is.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/16.is.js",
                "content": "Object.prototype._is = function (x, y) {\n    // 判断是否是同一对象（包括 +0/-0） +0和-0是不等的\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        // 判断是否是 NaN,如果是NAN,is就是相等的\n        return x !== x && y !== y\n    }\n}\n",
                "url": "",
                "sortKey": 16
              },
              {
                "name": "17.json.stringify.TODO.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/17.json.stringify.TODO.js",
                "content": "/** https://juejin.cn/post/6844903861971320846?searchId=20240811235902CCC1D8113CE9807307E3 */\n",
                "url": "",
                "sortKey": 17
              },
              {
                "name": "18.json.parse.TODO.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/18.json.parse.TODO.js",
                "content": "",
                "url": "",
                "sortKey": 18
              },
              {
                "name": "19.call bind apply.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/19.call bind apply.js",
                "content": "// 在调用 func 时要使用的 this 值。如果函数不在严格模式下，\n// null 和 undefined 将被替换为全局对象，并且原始值将被转换为对象。\nFunction.prototype._call = function (context, ...args) {\n    context = !context ? window : context\n    context._fn = this\n    const result = context._fn(...args)\n    delete context._fn\n    return result\n}\nFunction.prototype._bind = function (context, ...args1) {\n    context = !context ? window : context\n    context._fn = this\n    return function (...args2) {\n        const result = context._fn(...[...args1, ...args2])\n        delete context._fn\n        return result\n    }\n}\nFunction.prototype._apply = function (context, args) {\n    context = !context ? window : context\n    context._fn = this\n    const result = context._fn(...args)\n    delete context._fn\n    return result\n}\n",
                "url": "",
                "sortKey": 19
              },
              {
                "name": "20.typeof.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/20.typeof.js",
                "content": "// typeof null 是object\n// 基础数据类型：number string boolean undefined null symbol\n// 引用数据类型：object array\n",
                "url": "",
                "sortKey": 20
              },
              {
                "name": "21.instanceof.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/21.instanceof.js",
                "content": "// 针对于引用数据类型，基本数据类型判断不了\n\n/** 判断左侧是否属于构造函数\n * left 实例\n * right 构造函数\n */\nfunction myInstanceOf(left, rigth) {\n    let __proto = left.__proto__,\n        prototype = rigth.prototype\n    while (__proto) {\n        if (prototype === __proto) {\n            return true\n        }\n        __proto = __proto.__proto__\n    }\n    return false\n}\n\nconsole.log(myInstanceOf([], Array))\n",
                "url": "",
                "sortKey": 21
              },
              {
                "name": "22.new.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/22.new.js",
                "content": "// （1）首先创建了一个新的空对象\n// （2）设置原型，将对象的原型设置为函数的 prototype 对象。\n// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\nfunction myNew(fn, ...args) {\n    const obj = Object.create(fn.prototype)\n    const res = fn.call(obj, ...args)\n    return typeof res === \"object\" ? res : obj\n}\nfunction Person(name) {\n    this.name = name\n}\nPerson.prototype.say = function () {\n    console.log(\"hello\")\n}\nconst obj = myNew(Person, \"ljq\")\nobj.say()\nconsole.log(obj)\n",
                "url": "",
                "sortKey": 22
              },
              {
                "name": "23.trim.js",
                "type": "file",
                "path": "src/10.前端相关手写/1.实现js原生方法/23.trim.js",
                "content": "String.prototype._trim = function () {\n    let left = 0,\n        right = this.length - 1\n    for (let i = 0; i < this.length; i++) {\n        if (this[i] === \" \") {\n            left++\n        } else {\n            break\n        }\n    }\n    for (let i = right; i >= 0; i--) {\n        if (this[i] === \" \") {\n            right--\n        } else {\n            break\n        }\n    }\n    return this.slice(left, right + 1)\n}\n\nlet str = \"    hello     ww   \"\nconsole.log(str._trim())\n",
                "url": "",
                "sortKey": 23
              }
            ],
            "sortKey": 1
          },
          {
            "name": "2.实现Promise相关",
            "type": "directory",
            "path": "src/10.前端相关手写/2.实现Promise相关",
            "children": [
              {
                "name": "1.all.js",
                "type": "file",
                "path": "src/10.前端相关手写/2.实现Promise相关/1.all.js",
                "content": "Promise._all = function (promises) {\n    let count = 0 // 记录完成的数量\n    const result = []\n    return new Promise((resolve, reject) => {\n        promises.forEach((_promise, _idx) => {\n            _promise().then((res) => {\n                result[_idx] = res\n                count++\n                if (count === promises.length) {\n                    resolve(result)\n                }\n            })\n        })\n    })\n}\nfunction my(time) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(time)\n        }, time)\n    })\n}\n\nconst promise1 = () => my(2000)\nconst promise2 = () => my(3000)\nconst promise3 = () => my(5000)\nconst promise4 = () => my(4000)\n\nPromise._all([promise1, promise2, promise3, promise4]).then((res) => {\n    console.log(res)\n})\n",
                "url": "",
                "sortKey": 1
              },
              {
                "name": "2.finally.js",
                "type": "file",
                "path": "src/10.前端相关手写/2.实现Promise相关/2.finally.js",
                "content": "// 1.承接上一次Promise的值\n// 2.return的值不会被任何地方接收\nPromise.prototype._finally = function (callback) {\n    return this.then(\n        (res) => {\n            callback()\n            return res\n        },\n        (err) => {\n            callback()\n            throw err\n        }\n    )\n}\n\nfunction my(time) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(time)\n        }, time)\n    })\n}\nconst promise1 = () => my(300)\n\n// promise1()\n//     .then((res) => {\n//         console.log(res)\n//         return \"111\"\n//     })\n//     ._finally((res) => {\n//         console.log(res)\n//         return \"hellow\"\n//     })\n//     .then((res) => {\n//         console.log(\"finally\", res)\n//     })\n\n// promise1()\n//     .then((res) => {\n//         console.log(res)\n//         return \"111\"\n//     })\n//     .finally((res) => {\n//         console.log(res)\n//         return \"hellow\"\n//     })\n//     .then((res) => {\n//         console.log(\"finally\", res)\n//     })\nPromise.reject(\"err\")\n    .finally(() => {\n        console.log(\"finally\")\n    })\n    .catch(console.log)\n    .then((res) => console.log(res))\n",
                "url": "",
                "sortKey": 2
              },
              {
                "name": "3.allSettled.js",
                "type": "file",
                "path": "src/10.前端相关手写/2.实现Promise相关/3.allSettled.js",
                "content": "// 获取所有Promise对象的状态\n\nPromise._allSettled = function (promises) {\n    let count = 0,\n        result = []\n    return new Promise((resolve) => {\n        promises.forEach((_promise, _idx) => {\n            _promise\n                .then(\n                    (res) => {\n                        result[_idx] = {\n                            status: \"fulfilled\",\n                            value: res,\n                        }\n                    },\n                    (err) => {\n                        result[_idx] = {\n                            status: \"rejected\",\n                            value: err,\n                        }\n                    }\n                )\n                .finally(() => {\n                    count++\n                    if (count >= promises.length) {\n                        resolve(result)\n                    }\n                })\n        })\n    })\n}\n\nconst pro = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        reject(3)\n    }, 1000)\n})\n\nPromise.allSettled([pro, Promise.resolve(1), Promise.reject(2)]).then((data) => {\n    console.log(data)\n})\n\nPromise._allSettled([pro, Promise.resolve(1), Promise.reject(2)]).then((data) => {\n    console.log(data)\n})\n",
                "url": "",
                "sortKey": 3
              },
              {
                "name": "4.race.js",
                "type": "file",
                "path": "src/10.前端相关手写/2.实现Promise相关/4.race.js",
                "content": "// 手写Promise.race\nPromise._race = function (promises) {\n    return new Promise((resolve, reject) => {\n        promises.forEach((_promise) => {\n            _promise\n                .then((res) => {\n                    resolve(res)\n                })\n                .catch(reject)\n        })\n    })\n}\n\nconst promise1 = new Promise((resolve) =>\n    setTimeout(() => {\n        resolve(1)\n    }, 300)\n)\n\nconst promise2 = new Promise((reject) => {\n    setTimeout(() => {\n        reject(2)\n    }, 400)\n})\n\nPromise._race([promise1, promise2])\n    .then((res) => {\n        console.log(res)\n    })\n    .catch(console.log)\n",
                "url": "",
                "sortKey": 4
              },
              {
                "name": "5.catch.js",
                "type": "file",
                "path": "src/10.前端相关手写/2.实现Promise相关/5.catch.js",
                "content": "// 实现catch函数\nPromise.prototype._catch = function (callback) {\n    this.then(undefined, (err) => callback(err))\n}\n",
                "url": "",
                "sortKey": 5
              },
              {
                "name": "6.resolve.js",
                "type": "file",
                "path": "src/10.前端相关手写/2.实现Promise相关/6.resolve.js",
                "content": "// 实现resolve函数\n// - thenable对象\n// - promise对象\n// - 值\nfunction myResolve(value) {\n    // 如果 value 已经是 Promise 对象，则直接返回该 Promise 对象\n    if (value instanceof Promise) {\n        return value\n    }\n    // 如果 value 是 thenable 对象，则包装成 Promise 对象并返回\n    if (value && typeof value.then === \"function\") {\n        return new Promise(function (resolve, reject) {\n            value.then(resolve, reject)\n        })\n    }\n    // 将传入的值作为 Promise 的成功值，并返回 Promise 对象\n    return new Promise(function (resolve) {\n        resolve(value)\n    })\n}\n\n// thenable对象\nconst obj = {\n    then(resolve, reject) {\n        resolve(\"111\")\n    },\n}\n",
                "url": "",
                "sortKey": 6
              },
              {
                "name": "7.reject.js",
                "type": "file",
                "path": "src/10.前端相关手写/2.实现Promise相关/7.reject.js",
                "content": "// 实现reject函数\n// - 普通值 直接catch捕获\n// - promise 抛出这个promis，不会重复利用promise的值\nPromise._reject = function (value) {\n    return new Promise((_, reject) => {\n        reject(value)\n    })\n}\n",
                "url": "",
                "sortKey": 7
              }
            ],
            "sortKey": 2
          },
          {
            "name": "3.Promise场景题",
            "type": "directory",
            "path": "src/10.前端相关手写/3.Promise场景题",
            "children": [
              {
                "name": "1.交通灯.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/1.交通灯.js",
                "content": "// 红灯3秒亮一次，绿灯2秒亮一次，黄灯1秒亮一次；如何让三个灯不断交替重复亮灯？\n// 要求：用Promise实现\nfunction red() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(\"red\")\n            resolve()\n        }, 3000)\n    })\n}\nfunction green() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(\"green\")\n            resolve()\n        }, 2000)\n    })\n}\nfunction yellow() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(\"yellow\")\n            resolve()\n        }, 1000)\n    })\n}\n\n// 递归\nconst step = () => red().then(() => green().then(() => yellow().then(() => step())))\nstep()\n\n// async await实现\nconst taskRunner = async () => {\n    await red()\n    await green()\n    await yellow()\n    taskRunner()\n}\n\ntaskRunner()\n",
                "url": "",
                "sortKey": 1
              },
              {
                "name": "2.封装一个fetch请求.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/2.封装一个fetch请求.js",
                "content": ";(async () => {\n    class HttpRequestUtil {\n        async get(url) {\n            const res = await fetch(url)\n            const data = await res.json()\n            return data\n        }\n        async post(url, data) {\n            const res = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify(data),\n            })\n            const result = await res.json()\n            return result\n        }\n        async put(url, data) {\n            const res = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                data: JSON.stringify(data),\n            })\n            const result = await res.json()\n            return result\n        }\n        async delete(url, data) {\n            const res = await fetch(url, {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                data: JSON.stringify(data),\n            })\n            const result = await res.json()\n            return result\n        }\n    }\n    const httpRequestUtil = new HttpRequestUtil()\n    const res = await httpRequestUtil.get(\"http://golderbrother.cn/\")\n    console.log(res)\n})()\n",
                "url": "",
                "sortKey": 2
              },
              {
                "name": "3.重复执行函数.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/3.重复执行函数.js",
                "content": "// 基于 tapable 思想，构造异步任务串\n// https://juejin.cn/post/6844903700872298510\nconst repeat = (cb, delay = 1000, times = 5) => {\n    /* 高阶函数 */\n    return function (text) {\n        const AsyncFn = () =>\n            new Promise((resolve) => {\n                setTimeout(() => {\n                    cb(text)\n                    resolve()\n                }, delay)\n            })\n\n        // 构建异步任务串\n        new Array(times).fill(AsyncFn).reduce((acc, cur) => {\n            return acc.then(() => cur())\n        }, Promise.resolve())\n    }\n}\n\nconst mockLog = repeat(console.log)\n\nmockLog(\"Hello world!!\")\n",
                "url": "",
                "sortKey": 3
              },
              {
                "name": "4.网络请求时间限制.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/4.网络请求时间限制.js",
                "content": "// 网络请求，超过2s就报错，小于2s返回正常结果\nfunction Limit(promises) {\n    return new Promise((resolve, reject) => {\n        Promise.race([...promises, requestErr()])\n            .then((res) => {\n                console.log(\"成功\")\n                resolve()\n            })\n            .catch((err) => {\n                console.log(\"失败\")\n                reject()\n            })\n    })\n}\n\nconst requestPromise = () => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"请求成功\")\n            resolve()\n        }, 1000)\n    })\n}\n\nconst requestErr = () => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"请求失败\")\n            reject()\n        }, 2000)\n    })\n}\n\nLimit([requestPromise()])\n",
                "url": "",
                "sortKey": 4
              },
              {
                "name": "5.请求5s未完成就终止.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/5.请求5s未完成就终止.js",
                "content": "// AbortController 它能够中止 fetch 请求、各种响应主体或者流的消耗。\n// @url https://juejin.cn/post/7112699475327615006\n",
                "url": "https://juejin.cn/post/7112699475327615006",
                "sortKey": 5
              },
              {
                "name": "6.实现一个sleep函数.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/6.实现一个sleep函数.js",
                "content": "function sleep(delay) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, delay)\n    })\n}\n",
                "url": "",
                "sortKey": 6
              },
              {
                "name": "7.setTime实现setInterval.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/7.setTime实现setInterval.js",
                "content": "// TODO:实现取消\nfunction mySetInterval(callback, delay) {\n    const recurit = () => {\n        setTimeout(() => {\n            callback()\n            recurit()\n        }, delay)\n    }\n    recurit()\n}\nmySetInterval(() => {\n    console.log(\"111\")\n}, 1000)\n",
                "url": "",
                "sortKey": 7
              },
              {
                "name": "8.奇怪的输出题.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/8.奇怪的输出题.js",
                "content": "// Promise.resolve()\n//     .then(() => {\n//         console.log(0)\n//         return 4\n//     })\n//     .then(console.log)\n// Promise.resolve()\n//     .then(() => {\n//         console.log(1)\n//     })\n//     .then(() => {\n//         console.log(2)\n//     })\n//     .then(() => {\n//         console.log(3)\n//     })\n//     .then(() => {\n//         console.log(5)\n//     })\n//     .then(() => {\n//         console.log(6)\n//     })\n// 0 1 4 2 3 5 6\nPromise.resolve()\n    .then(() => {\n        console.log(0)\n        return Promise.resolve(4)\n    })\n    .then((res) => {\n        console.log(res)\n    })\n\nPromise.resolve()\n    .then(() => {\n        console.log(1)\n    })\n    .then(() => {\n        console.log(2)\n    })\n    .then(() => {\n        console.log(3)\n    })\n    .then(() => {\n        console.log(5)\n    })\n    .then(() => {\n        console.log(6)\n    })\n\n// https://juejin.cn/post/6949699310732869669\n",
                "url": "",
                "sortKey": 8
              },
              {
                "name": "10.封装ajax请求.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/10.封装ajax请求.js",
                "content": "function axios(url) {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest()\n        xhr.open(\"Get\", url)\n        xhr.onreadystatechange = function () {\n            if (this.readyState !== 4) {\n                return\n            }\n            if (this.status >= 200 && this.status < 400) {\n                resolve(this.response)\n            } else {\n                reject(new Error(this.statusText))\n            }\n        }\n        xhr.onerror = function () {\n            reject(new Error(this.statusText))\n        }\n\n        //设置响应数据类型\n        xhr.setRequestHeader(\"Accept\", \"application/json\")\n        xhr.send()\n    })\n}\n",
                "url": "",
                "sortKey": 10
              },
              {
                "name": "11.setInterval模拟setTimeOut.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/11.setInterval模拟setTimeOut.js",
                "content": "function myTimeOut(cb, delay) {\n    const timer = setInterval(() => {\n        cb()\n        clearInterval(timer)\n    }, delay)\n}\nmyTimeOut(() => console.log(111111), 1000)\n",
                "url": "",
                "sortKey": 11
              },
              {
                "name": "12.promise如何中断后面的then.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/12.promise如何中断后面的then.js",
                "content": "// Promise.resolve()\n//     .then(() => {\n//         console.log(111)\n//     })\n//     .then(() => {\n//         console.log(222)\n//     })\n// 打印 111 222\n\nPromise.resolve()\n    .then(() => {\n        console.log(1111)\n        return new Promise(() => {})\n    })\n    .then(() => {\n        console.log(2222)\n    })\n",
                "url": "",
                "sortKey": 12
              },
              {
                "name": "13.实现一个精准的计时器.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/13.实现一个精准的计时器.js",
                "content": "// https://juejin.cn/post/7128231937457520671    https://juejin.cn/post/7029252274299879454\n",
                "url": "",
                "sortKey": 13
              },
              {
                "name": "14.一次处理2个任务.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/14.一次处理2个任务.js",
                "content": "function task(time = 1000) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            const timestamp = (Date.now() / 1000) | 0\n            console.log(timestamp)\n            resolve(timestamp)\n        }, time)\n    })\n}\n\nasync function concurrent(tasks, max = 10) {\n    const results = []\n    const poolList = new Set()\n    for (let i of tasks) {\n        if (poolList.size === max) {\n            await Promise.race(poolList)\n        }\n        let task = i()\n        results.push(task)\n        poolList.add(task)\n        task.then(() => poolList.delete(task))\n    }\n    return Promise.allSettled(results)\n}\n\nconcurrent([task, () => task(2000), task, task, task, task, task, task, task], 2).then((res) => {\n    console.log(res)\n})\n",
                "url": "",
                "sortKey": 14
              },
              {
                "name": "15.设计一个简单的任务队列.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/15.设计一个简单的任务队列.js",
                "content": "// 题目\n//  new Quene()\n// .task(1000, () => {\n//   console.log(1)\n// })\n// .task(2000, () => {\n//   console.log(2)\n// })\n// .task(1000, () => {\n//   console.log(3)\n// })\n// .start()\n\n// function Quene() { ... } //补全代码\n\nfunction Quene() {\n    this.queue = []\n    this.task = function (time, callback) {\n        let promise = () =>\n            new Promise((resolve) => {\n                setTimeout(() => {\n                    callback()\n                    resolve()\n                }, time)\n            })\n        this.queue.push(promise)\n        return this\n    }\n    this.start = function () {\n        this.queue.reduce((pre, cur) => pre.then(() => cur()), Promise.resolve())\n    }\n}\nnew Quene()\n    .task(1000, () => {\n        console.log(1)\n    })\n    .task(2000, () => {\n        console.log(2)\n    })\n    .task(1000, () => {\n        console.log(3)\n    })\n    .start()\n",
                "url": "",
                "sortKey": 15
              },
              {
                "name": "16.实现调度器.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/16.实现调度器.js",
                "content": "class Schedular {\n    constructor(limit) {\n        this.limit = limit\n        this.queue = []\n        this.run = new Set() // 存放正在执行的任务\n    }\n\n    add(time, value) {\n        const mock = () =>\n            new Promise((resolve) => {\n                setTimeout(() => {\n                    console.log(value)\n                    resolve(value)\n                }, time)\n            })\n\n        this.queue.push(mock)\n    }\n    async taskStart() {\n        for (let promise of this.queue) {\n            if (this.run.size >= this.limit) {\n                await Promise.race(this.run)\n            }\n            let task = promise()\n\n            task.then(() => this.run.delete(task))\n            this.run.add(task)\n        }\n    }\n}\n\nconst scheduler = new Schedular(2)\nconst addTask = (time, order) => {\n    scheduler.add(time, order)\n}\naddTask(1000, \"1\")\naddTask(500, \"2\")\naddTask(300, \"3\")\naddTask(400, \"4\")\nscheduler.taskStart()\n",
                "url": "",
                "sortKey": 16
              },
              {
                "name": "17.有并发限制的promiseall.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/17.有并发限制的promiseall.js",
                "content": "/** https://github.com/Sunny-117/js-challenges/issues/147 */\n// async-pool思想 和 compose思想 基于递归\nPromise._all = function (promises) {\n    const limit = 2\n    const result = []\n    const runnerCount = []\n    for (let i = 0; i < promises.length; i++) {\n        promises.then(() => {})\n    }\n}\n",
                "url": "",
                "sortKey": 17
              },
              {
                "name": "18.实现错误重新请求，并控制重试次数.js",
                "type": "file",
                "path": "src/10.前端相关手写/3.Promise场景题/18.实现错误重新请求，并控制重试次数.js",
                "content": "",
                "url": "",
                "sortKey": 18
              }
            ],
            "sortKey": 3
          },
          {
            "name": "4.js常考手写题",
            "type": "directory",
            "path": "src/10.前端相关手写/4.js常考手写题",
            "children": [
              {
                "name": "1.LRU缓存.ts",
                "type": "file",
                "path": "src/10.前端相关手写/4.js常考手写题/1.LRU缓存.ts",
                "content": "// 最近最少使用\n/**\n * @url https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked\n */\n\n// map迭代的顺序是插入的顺序\nclass LRUCache {\n    capacity: number\n    map: Map<number, number>\n    constructor(capacity: number) {\n        this.capacity = capacity\n        this.map = new Map()\n    }\n\n    // 每次获取值的时候，重新赋值给map。\n    get(key: number): number {\n        if (this.map.has(key)) {\n            const value = this.map.get(key)\n            this.map.delete(key)\n            this.map.set(key, value!)\n            return value!\n        }\n        return -1\n    }\n\n    put(key: number, value: number): void {\n        if (this.map.size === this.capacity) {\n            // 删除最近最少使用的了\n            const deleteKey = this.map.keys().next().value\n            this.map.delete(Number(deleteKey))\n        }\n        if (this.map.has(key)) {\n            this.map.delete(key)\n        }\n        this.map.set(key, value)\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n\nlet lRUCache = new LRUCache(2)\nlRUCache.put(1, 1) // 缓存是 {1=1}\nlRUCache.put(2, 2) // 缓存是 {1=1, 2=2}\nlRUCache.get(1) // 返回 1\nlRUCache.put(3, 3) // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2) // 返回 -1 (未找到)\nlRUCache.put(4, 4) // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1) // 返回 -1 (未找到)\nlRUCache.get(3) // 返回 3\nlRUCache.get(4) // 返回 4\n",
                "url": "https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked",
                "sortKey": 1
              },
              {
                "name": "2.数组转树.js",
                "type": "file",
                "path": "src/10.前端相关手写/4.js常考手写题/2.数组转树.js",
                "content": "const items = [\n    { id: 1, name: \"Item 1\", parentId: null },\n    { id: 2, name: \"Item 1.1\", parentId: 1 },\n    { id: 3, name: \"Item 1.2\", parentId: 1 },\n    { id: 4, name: \"Item 2\", parentId: null },\n    { id: 5, name: \"Item 2.1\", parentId: 4 },\n]\nconst arrToTree = (nums, parentId = null) => {\n    const tree = []\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i].parentId === parentId) {\n            const children = arrToTree(nums, nums[i].id)\n            nums[i].children = children\n            tree.push(nums[i])\n        }\n    }\n    return tree\n}\n\nconsole.log(\"arrToTree(items)\", arrToTree(items))\n",
                "url": "",
                "sortKey": 2
              },
              {
                "name": "3.树转数组.js",
                "type": "file",
                "path": "src/10.前端相关手写/4.js常考手写题/3.树转数组.js",
                "content": "const tree = [\n    {\n        id: 1,\n        nick: \"111\",\n        children: [{ id: 6, nick: \"666\" }],\n    },\n    {\n        id: 2,\n        nick: \"222\",\n        children: [\n            {\n                id: 3,\n                nick: \"333\",\n                children: [\n                    {\n                        id: 4,\n                        nick: \"444\",\n                        children: [\n                            {\n                                id: 5,\n                                nick: \"555\",\n                                children: [\n                                    { id: 8, nick: \"888\" },\n                                    { id: 9, nick: \"999\" },\n                                    { id: 10, nick: \"aaa\" },\n                                    { id: 11, nick: \"bbb\" },\n                                ],\n                            },\n                        ],\n                    },\n                    { id: 7, nick: \"777\" },\n                ],\n            },\n        ],\n    },\n]\n\nconst treeToArray = (tree) => {\n    const arr = []\n    for (let i = 0; i < tree.length; i++) {\n        if (tree[i].children) {\n            arr.push(...treeToArray(tree[i].children))\n            arr.push(tree[i])\n        } else {\n            arr.push(tree[i])\n        }\n    }\n    return arr\n}\n\nconsole.log(\"treeToArray(tree)\", treeToArray(tree))\n",
                "url": "",
                "sortKey": 3
              },
              {
                "name": "4.函数科里化.js",
                "type": "file",
                "path": "src/10.前端相关手写/4.js常考手写题/4.函数科里化.js",
                "content": "// 实现一个add方法, 使计算结果能够满足以下预期\n// add(1)(2)(3)() = 6\n// add(1,2,3)(4)() = 10\n// add(1)(2)(3)(4)(5)() = 15\n\nfunction add(...arg1) {\n    let totalSum = arg1.reduce((acc, cur) => acc + cur, 0)\n    return function result(...arg2) {\n        if (arg2.length === 0) {\n            return totalSum\n        } else {\n            totalSum += arg2.reduce((acc, cur) => acc + cur, 0)\n            return result\n        }\n    }\n}\nconsole.log(add(1)(2)(3)())\nconsole.log(add(1, 2, 3)(4)())\nconsole.log(add(1)(2)(3)(4)(5)())\n",
                "url": "",
                "sortKey": 4
              },
              {
                "name": "5.继承的几种方法.js",
                "type": "file",
                "path": "src/10.前端相关手写/4.js常考手写题/5.继承的几种方法.js",
                "content": "// 原型链继承\nfunction Parent() {\n    this.color = [\"red\", \"blue\"]\n}\nfunction Child() {}\nChild.prototype = new Parent()\nconst child1 = new Child()\nchild1.color.push(\"cc\")\nconsole.log(\"child1.color\", child1.color)\nconst child2 = new Child()\nconsole.log(\"child2.color\", child2.color)\n\n// 缺点：如果继承的对象是一个引用类型，则所有的属性都会被影响\n// ===================================================\n// 构造函数继承\nfunction Parent1() {\n    this.color = [\"red\", \"blue\"]\n}\nfunction Child1() {\n    Parent1.call(this)\n}\n\n// 缺点：不能够继承原型上的属性\n// ====================================================\n\n// 组合继承\nfunction Parent2() {\n    this.color = [\"red\", \"blue\"]\n}\nfunction Child2() {\n    Parent1.call(this)\n}\nChild2.prototype = new Parent2()\n\n// 缺点：同1\n\n// 寄生组合式继承\nfunction Parent3() {\n    this.color = [\"red\", \"blue\"]\n}\nfunction Child3() {\n    Parent1.call(this)\n}\nChild3.prototype = Object.create(Parent3.prototype)\n",
                "url": "",
                "sortKey": 5
              },
              {
                "name": "6.生成唯一id.js",
                "type": "file",
                "path": "src/10.前端相关手写/4.js常考手写题/6.生成唯一id.js",
                "content": "function GetUniqueID() {\n    // 当前时间转成 36 进制字符串\n    var time = Date.now().toString(36)\n    console.log(\"🚀 ~ GetUniqueID ~ time:\", time)\n    // 当前随机数转成 36 进制字符串\n    var random = Math.random().toString(36)\n    // 去除随机数的 0. 字符串\n    random = random.substring(2, random.length)\n    // 返回唯一ID\n    return random + time\n}\n// 测试输出\nconsole.log(GetUniqueID())\n",
                "url": "",
                "sortKey": 6
              },
              {
                "name": "7.十进制转十六进制.js",
                "type": "file",
                "path": "src/10.前端相关手写/4.js常考手写题/7.十进制转十六进制.js",
                "content": "/** // notice:余数法，以十六进制为例,每一次取余数之后，然后进行取反操作 */\nconst binaryConversion = (nums) => {\n    let remainder = [] // 余数\n    while (nums !== 0) {\n        const temp = nums % 16\n        remainder.push(temp)\n        nums = Math.floor(nums / 16)\n    }\n    return Number.parseInt(remainder.reverse().join(\"\"))\n}\n\nconsole.log(\"binaryConversion(120)\", binaryConversion(120))\n",
                "url": "",
                "sortKey": 7
              },
              {
                "name": "8.最小堆.js",
                "type": "file",
                "path": "src/10.前端相关手写/4.js常考手写题/8.最小堆.js",
                "content": "class MinHeap {\n    constructor() {\n        /** 用数组来存储堆的形式 */\n        this.heap = []\n    }\n\n    /** 交换两个节点的位置 */\n    swap(i1, i2) {\n        const temp = this.heap[i1]\n        this.heap[i1] = this.heap[i2]\n        this.heap[i2] = temp\n    }\n\n    /** 获取指定节点的父节点下标 */\n    getParentIndex(i) {\n        return Math.floor((i - 1) / 2)\n    }\n\n    /** 获取左孩子节点下标 */\n    getLeftIndex(i) {\n        return 2 * i + 1\n    }\n\n    /** 获取右孩子节点下标 */\n    getRightIndex(i) {\n        return 2 * i + 2\n    }\n\n    /** 上移操作 */\n    shiftUp(index) {\n        if (index === 0) {\n            return\n        }\n        /** 父节点下标 */\n        const parentIndex = this.getParentIndex(index)\n        if (this.heap[index] < this.heap[parentIndex]) {\n            this.swap(index, parentIndex)\n            this.shiftUp(parentIndex)\n        }\n    }\n\n    /** 下移操作 */\n    shiftDown(index) {\n        const leftIndex = this.getLeftIndex(index)\n        const rightIndex = this.getRightIndex(index)\n        if (leftIndex >= this.heap.length) {\n            return\n        }\n        if (rightIndex >= this.heap.length) {\n            return\n        }\n\n        if (this.heap[index] > this.heap[leftIndex]) {\n            this.swap(index, leftIndex)\n            this.shiftDown(leftIndex)\n        }\n        if (this.heap[index] > this.heap[rightIndex]) {\n            this.swap(index, rightIndex)\n            this.shiftDown(rightIndex)\n        }\n    }\n\n    /** 插入节点的值 */\n    insertNode(val) {\n        this.heap.push(val)\n        this.shiftUp(this.heap.length - 1)\n    }\n\n    /** 去除栈顶元素  */\n    pop() {\n        this.heap[0] = this.heap.pop()\n        this.shiftDown(0)\n    }\n\n    /** 获取栈顶元素 */\n    peek() {\n        return this.heap[0]\n    }\n}\nconst heap = new MinHeap()\n\nconst arr = [3, 1, 2, 3, 4, 1, 4, 2, 1, 2, 4, -1]\narr.forEach((item) => {\n    heap.insertNode(item)\n})\nconsole.log(heap)\n",
                "url": "",
                "sortKey": 8
              }
            ],
            "sortKey": 4
          }
        ],
        "sortKey": 10
      },
      {
        "name": "11.单调栈",
        "type": "directory",
        "path": "src/11.单调栈",
        "children": [
          {
            "name": "1.每日温度.ts",
            "type": "file",
            "path": "src/11.单调栈/1.每日温度.ts",
            "content": "// @ts-nocheck\n/**\n * @url https://leetcode.cn/problems/daily-temperatures/description/\n */\n\n// ==========  //\n\n// 暴力解法 时间复杂度 O(n^2)\n/**\n * @param {number[]} temperatures\n * @return {number[]}\n */\nvar dailyTemperatures = function (temperatures) {\n    let curDayIdx = 0\n    const res = new Array(temperatures.length).fill(0)\n    while (curDayIdx < temperatures.length) {\n        let explorePointer = curDayIdx\n        while (explorePointer < temperatures.length && temperatures[explorePointer] <= temperatures[curDayIdx]) {\n            explorePointer++\n        }\n        if (explorePointer === temperatures.length) {\n            res[curDayIdx] = 0\n        }else {\n            res[curDayIdx] = explorePointer - curDayIdx\n        }\n        curDayIdx++\n    }\n    return res\n};\n\n// 单调栈 时间复杂度 O(n)\n/**\n * @param {number[]} temperatures\n * @return {number[]}\n */\n\nvar dailyTemperatures = function(temperatures) {\n    const stack = []\n    const res = new Array(temperatures.length).fill(0)\n    for (let i = 0; i < temperatures.length; i++) {\n        const temperature = temperatures[i]\n        if (!stack.length) {\n            stack.push(i)\n        }else {\n            while (stack.length && temperature > temperatures[stack[stack.length - 1]]) {\n                res[stack[stack.length - 1]] = i - stack[stack.length - 1]\n                stack.pop()\n            }\n            stack.push(i)\n        }\n    }\n    return res\n};",
            "url": "https://leetcode.cn/problems/daily-temperatures/description/",
            "sortKey": 1
          },
          {
            "name": "2.下一个更大的元素.ts",
            "type": "file",
            "path": "src/11.单调栈/2.下一个更大的元素.ts",
            "content": "// @ts-nocheck\n/**\n * @url https://leetcode.cn/problems/next-greater-element-i/description/\n */\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\n\n// !notice: 注意题目描述\nvar nextGreaterElement = function (nums1, nums2) {\n  const stack = [];\n  const map = new Map(); // key为值，value为下标\n  const res = new Array(nums1.length).fill(-1);\n  for (let i = 0; i < nums1.length; i++) {\n    map.set(nums1[i], i);\n  }\n\n  for (let i = 0; i < nums2.length; i++) {\n    if (!stack.length) {\n      stack.push(i);\n    } else {\n      while (stack.length && nums2[i] > nums2[stack[stack.length - 1]]) {\n        if (map.has(nums2[stack[stack.length - 1]])) {\n          const idx = map.get(nums2[stack[stack.length - 1]]);\n          res[idx] = nums2[i];\n        }\n        stack.pop();\n      }\n      stack.push(i);\n    }\n  }\n  return res;\n};\n",
            "url": "https://leetcode.cn/problems/next-greater-element-i/description/",
            "sortKey": 2
          },
          {
            "name": "3.下一个更大的元素2.ts",
            "type": "file",
            "path": "src/11.单调栈/3.下一个更大的元素2.ts",
            "content": "// @ts-nocheck\n/**\n * @url https://leetcode.cn/problems/next-greater-element-ii/description/\n */\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\n// !notice: 环形数组的一个遍历\nvar nextGreaterElements = function (nums) {\n  const stack = [];\n  const res = new Array(nums.length).fill(-1);\n  for (let i = 0; i < nums.length * 2; i++) {\n    const actualIdx = i % nums.length;\n    if (!stack.length) {\n      stack.push(actualIdx);\n    } else {\n      while (stack.length && nums[actualIdx] > nums[stack[stack.length - 1]]) {\n        res[stack[stack.length - 1]] = nums[actualIdx];\n        stack.pop();\n      }\n      stack.push(actualIdx);\n    }\n  }\n  return res;\n};\n",
            "url": "https://leetcode.cn/problems/next-greater-element-ii/description/",
            "sortKey": 3
          },
          {
            "name": "4.接雨水.ts",
            "type": "file",
            "path": "src/11.单调栈/4.接雨水.ts",
            "content": "// @ts-nocheck\n/**\n * @url https://leetcode.cn/problems/trapping-rain-water/description/\n */\n/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function (height) {\n  const stack = []; // 维护一个单调递增的序列\n  let res = 0; // 表示结果\n  for (let i = 0; i < height.length; i++) {\n    if (!stack.length) {\n      stack.push(i);\n    } else {\n      while (stack.length && height[i] > height[stack[stack.length - 1]]) {\n        const mid = height[stack.pop()];\n        if (stack.length) {\n          const leftIdx = stack[stack.length - 1];\n          const leftVal = height[leftIdx];\n          const rightVal = height[i];\n          res += (i - leftIdx - 1) * (Math.min(leftVal, rightVal) - mid);\n        }\n      }\n      stack.push(i); // 理解为计算以当前元素为底的情况\n    }\n  }\n  return res;\n};\n",
            "url": "https://leetcode.cn/problems/trapping-rain-water/description/",
            "sortKey": 4
          },
          {
            "name": "5.柱状图中最大的矩形.ts",
            "type": "file",
            "path": "src/11.单调栈/5.柱状图中最大的矩形.ts",
            "content": "// @ts-nocheck\n/**\n * @url https://leetcode.cn/problems/largest-rectangle-in-histogram/description/\n */\n",
            "url": "https://leetcode.cn/problems/largest-rectangle-in-histogram/description/",
            "sortKey": 5
          }
        ],
        "sortKey": 11
      }
    ],
    "sortKey": 0
  }
]
