# ğŸ“š 5.å¯¹ç§°äºŒå‰æ ‘

## ğŸ’» ä»£ç å®ç°
```typescript
/**
 * @url https://leetcode.cn/problems/symmetric-tree/description/
 */

class TreeNode {
    val: number
    left: TreeNode | null
    right: TreeNode | null
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = val === undefined ? 0 : val
        this.left = left === undefined ? null : left
        this.right = right === undefined ? null : right
    }
}

// notice:compareæ¯”è¾ƒå•ä¸ªå•ç‚¹çš„å‡½æ•°ï¼Œç„¶åæ¯”è¾ƒå·¦å­æ ‘ï¼Œå³å­æ ‘çš„èŠ‚ç‚¹

function isSymmetric(root: TreeNode | null): boolean {
    const compare = (left: TreeNode | null, right: TreeNode | null) => {
        const specialCondition = (left && !right) || (!left && right)
        const empty = !left && !right
        if (specialCondition) {
            return false
        }
        if (empty) {
            return true
        }
        if (left?.val !== right?.val) {
            return false
        }
        const inSide = compare(left!.left, right!.right)
        const outSide = compare(left!.right, right!.left)
        return inSide && outSide
    }
    if (!root) return true
    return compare(root.left, root.right)
}

/**
 * @description ç›¸åŒçš„æ ‘
 * @url https://leetcode.cn/problems/same-tree/
 */
function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {
    const compare = (p: TreeNode | null, q: TreeNode | null) => {
        // æ¯”è¾ƒå•èŠ‚ç‚¹
        const special = (!p && q) || (p && !q)
        if (special) return false
        const isEmpty = !p && !q
        if (isEmpty) return true
        if (p?.val !== q?.val) return false
        // æ¯”è¾ƒå­æ ‘
        return compare(p!.left, q!.left) && compare(p!.right, q!.right)
    }
    return compare(p, q)
}

/**
 * @description å¦ä¸€ä¸ªæ ‘çš„å­æ ‘
 * @url https://leetcode.cn/problems/subtree-of-another-tree/description/
 */

// compareæ¯”è¾ƒæ ¹èŠ‚ç‚¹ç›¸åŒçš„ä¸¤ä¸ªå­æ ‘æ˜¯å¦ç›¸åŒ
const compare = (root: TreeNode | null, subRoot: TreeNode | null) => {
    const specialCondition = (root && !subRoot) || (!root && subRoot)
    const empty = !root && !subRoot
    if (specialCondition) {
        return false
    }
    if (empty) {
        return true
    }
    if (root?.val !== subRoot?.val) {
        return false
    }
    return compare(root!.left, subRoot!.left) && compare(root!.right, subRoot!.right)
}
function isSubtree(root: TreeNode | null, subRoot: TreeNode | null): boolean {
    // å¯¹rootè¿›è¡Œdfsçš„éå†
    if (!root) return false
    return compare(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)
}

```
