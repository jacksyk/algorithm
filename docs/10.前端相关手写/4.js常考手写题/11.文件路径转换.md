# ðŸŽª 11.æ–‡ä»¶è·¯å¾„è½¬æ¢



## ðŸ“Š é¢˜ç›®æè¿°
æ˜¯å¦å­˜åœ¨

## ðŸ“Š ä»£ç å®žçŽ°
```typescript
const baseData = ['a/b/c/d/e', 'a/b/e/f/g', 'a/b/h', 'a/i/j', 'a/i/k'];
// è½¬æ¢æˆ ==========================>

// {
//   "key": "a",
//   "children": [
//     {
//       "key": "b",
//       "children": [
//         {
//           "key": "c",
//           "children": [
//             {
//               "key": "d",
//               "children": [
//                 { "key": "e" }
//               ]
//             }
//           ]
//         },
//         {
//           "key": "e",
//           "children": [
//             {
//               "key": "f",
//               "children": [
//                 { "key": "g" }
//               ]
//             }
//           ]
//         },
//         { "key": "h" }
//       ]
//     },
//     {
//       "key": "i",
//       "children": [
//         { "key": "j" },
//         { "key": "k" }
//       ]
//     }
//   ]
// }
function pathToTree(arr) {
    const res = [] // å­˜å‚¨ç»“æžœ
    // æ¯ä¸€æ¬¡å¾ªçŽ¯å¤„ç†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æžœæœ‰çš„è¯å°±è·³è¿‡ï¼Œå¦‚æžœæ²¡æœ‰çš„è¯ï¼Œåˆ™pushåˆ°children
    arr.forEach(item => {
        const nodeTokens = item.split('/')
        let targetPoint = res // ç›®æ ‡èŠ‚ç‚¹, å§‹ç»ˆæ˜¯æ•°ç»„

        for (let node of nodeTokens) {
            const nodeObj = {
                key: node,
                children: []
            }
            /** æ˜¯å¦å­˜åœ¨ */
            let isExit = false
            for (let j of targetPoint) {
                if (j.key === node) {
                    if (!j.children) {
                        j.children = []
                    }
                    targetPoint = j.children
                    isExit = true
                    break
                }
            }

            if (!isExit) {
                targetPoint.push(nodeObj)
                // ps: targetPointç„¶åŽæ“æŽ§å½“å‰èŠ‚ç‚¹çš„children
                if (!targetPoint[targetPoint.length - 1].children) {
                    targetPoint[targetPoint.length - 1].children = []
                }
                targetPoint = targetPoint[targetPoint.length - 1].children
            }
        }
    })
    return res
}

pathToTree(baseData)

// é€’å½’çš„åšæ³•
function pathToTree(paths) {
    const tree = [];

    // ps: nodeæ˜¯æ¯ä¸€å±‚çš„children  partsæ˜¯å½“å‰çš„ä¸€ä¸ªè·¯å¾„ indexæ˜¯å½“å‰è·¯å¾„çš„ä¸€ä¸ªç´¢å¼•
    const addNode = (node, parts, index) => {
        // ç»ˆæ­¢æ¡ä»¶ï¼šå¤„ç†å®Œæ‰€æœ‰è·¯å¾„ç‰‡æ®µ 
        if (index === parts.length) return;

        const current = parts[index];
        // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨åŒåèŠ‚ç‚¹ 
        let child = node.find(item => item.name === current);

        // åˆ›å»ºæ–°èŠ‚ç‚¹ï¼ˆåŒºåˆ†æ–‡ä»¶ä¸Žæ–‡ä»¶å¤¹ï¼‰
        if (!child) {
            child = {
                name: current,
                children: index === parts.length - 1 ? null : [] // æ–‡ä»¶èŠ‚ç‚¹æ— children 
            };
            node.push(child);
        }

        // é€’å½’å¤„ç†ä¸‹ä¸€çº§è·¯å¾„ï¼ˆä»…æ–‡ä»¶å¤¹éœ€è¦ç»§ç»­éåŽ†ï¼‰
        if (child.children) {
            addNode(child.children, parts, index + 1);
        }
    };

    paths.forEach(path => {
        const parts = path.split('/').filter(Boolean);  // è¿‡æ»¤ç©ºè·¯å¾„æ®µ
        addNode(tree, parts, 0);
    });
    return tree;
}
```
