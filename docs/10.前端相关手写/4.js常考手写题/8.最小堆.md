# ğŸ® 8.æœ€å°å †



## ğŸ“Œ é¢˜ç›®æè¿°
ç”¨æ•°ç»„æ¥å­˜å‚¨å †çš„å½¢å¼

## ğŸ“Œ ä»£ç å®ç°
```typescript
// ps:å †çš„ç»“æ„
class MinHeap {
    constructor() {
        /** ç”¨æ•°ç»„æ¥å­˜å‚¨å †çš„å½¢å¼ */
        this.heap = []
    }

    /** äº¤æ¢ä¸¤ä¸ªèŠ‚ç‚¹çš„ä½ç½® */
    swap(i1, i2) {
        const temp = this.heap[i1]
        this.heap[i1] = this.heap[i2]
        this.heap[i2] = temp
    }

    /** è·å–æŒ‡å®šèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸‹æ ‡ */
    getParentIndex(i) {
        return Math.floor((i - 1) / 2)
    }

    /** è·å–å·¦å­©å­èŠ‚ç‚¹ä¸‹æ ‡ */
    getLeftIndex(i) {
        return 2 * i + 1
    }

    /** è·å–å³å­©å­èŠ‚ç‚¹ä¸‹æ ‡ */
    getRightIndex(i) {
        return 2 * i + 2
    }

    /** ä¸Šç§»æ“ä½œ */
    shiftUp(index) {
        if (index === 0) {
            return
        }
        /** çˆ¶èŠ‚ç‚¹ä¸‹æ ‡ */
        const parentIndex = this.getParentIndex(index)
        if (this.heap[index] < this.heap[parentIndex]) {
            this.swap(index, parentIndex)
            this.shiftUp(parentIndex)
        }
    }

    /** ä¸‹ç§»æ“ä½œ */
    shiftDown(index) {
        const leftIndex = this.getLeftIndex(index)
        const rightIndex = this.getRightIndex(index)
        let midIndex;
        if (this.heap[leftIndex] < this.heap[rightIndex]) {
            midIndex = leftIndex
        } else {
            midIndex = rightIndex
        }

        if (this.heap[index] > this.heap[midIndex]) {
            this.swap(index, midIndex)
            this.shiftDown(midIndex)
        }

    }

    /** æ’å…¥èŠ‚ç‚¹çš„å€¼ */
    insertNode(val) {
        this.heap.push(val)
        this.shiftUp(this.heap.length - 1)
    }

    /** å»é™¤æ ˆé¡¶å…ƒç´   */
    pop() {
        if (this.heap.length === 0) {
            return null
        }
        if (this.heap.length === 1) {
            return this.heap.pop()
        }
        this.heap[0] = this.heap.pop()
        this.shiftDown(0)
    }

    /** è·å–æ ˆé¡¶å…ƒç´  */
    peek() {
        return this.heap[0]
    }
}
const heap = new MinHeap()

const arr = [3, 1, 2, 3, 4, 1, 4, 2, 1, 2, 4, -1]
arr.forEach((item) => {
    heap.insertNode(item)
})
console.log(heap)

// ps: å †æ’åº
// note:å€ŸåŠ©æ•°ç»„ç©ºé—´æ¥å®ç°
function heapSort(arr) {
    const minHeap = new MinHeap();
    const result = [];

    // æ„å»ºæœ€å°å †
    arr.forEach(item => {
        minHeap.insertNode(item);
    });

    // ä¾æ¬¡å–å‡ºå †é¡¶å…ƒç´ ï¼Œå¾—åˆ°å‡åºæ•°ç»„
    while (minHeap.heap.length > 0) {
        result.push(minHeap.peek());
        minHeap.pop();
    }

    return result;
}

console.log('heapSort(arr)', heapSort(arr))

// note: åŸåœ°å †æ’åº
function heapSortThroughSelf(arr) {
    const heap = new MinHeap();

    // æ„å»ºæœ€å°å †
    arr.forEach(item => {
        heap.insertNode(item);
    });

    // åŸåœ°æ’åº
    for (let i = 0; i < arr.length; i++) {
        arr[i] = heap.peek();
        heap.pop();
    }

    return arr;
}
```
